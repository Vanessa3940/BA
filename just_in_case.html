<!DOCTYPE html>
<html>
<head>
    <title>SAP App Task</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.1"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" />
    <style>
    /* Diese Regel wird nur auf Trials angewendet, denen wir die Klasse'vertically-centered-content' 
    im JavaScript-Code geben. */
      .jspsych-trial.vertically-centered-content .jspsych-display-element {
          display: flex;
          flex-direction: column;
          justify-content: center; /* Zentriert den Inhalt vertikal */
          height: 100%;            /* F√ºllt den gesamten Platz aus */
      }

      /* Diese Regel verhindert, dass unser App-Grid von der Zentrierung betroffen ist,
        und behebt das Problem der Rechtsverschiebung. */
      .jspsych-display-element {
          width: 100%;
      }

      /* Passt die Breite der Textbl√∂cke NUR auf den zentrierten Seiten an */
      .jspsych-trial.vertically-centered-content .jspsych-display-element > div {
        max-width: 900px; /* Beh√§lt die maximale Breite f√ºr Lesbarkeit bei */
        width: 100%;
        text-align: left; /* Stellt sicher, dass der Text linksb√ºndig bleibt */
      }
      
      html, body {
        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;
        overflow: hidden !important;
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background: #f5f6f7;
      }
      .sap-header {
        position: fixed;
        top: 0; left: 0; width: 100vw; z-index: 0;
        background: #fff;
        height: 82px;
        box-shadow: 0 2px 3px 0 rgba(0,0,0,0.05), 0 1px 0px 0 #e2e5e7;
        border-bottom: 1.5px solid #e2e5e7;
        display: flex;
        align-items: center;
        padding: 0 30px;
      }
      .sap-logo {
        height: 35px;
        width: 68px;
        margin-right: 24px;
      }
      .header-menu {
        display: flex;
        align-items: center;
        gap: 18px;
      }
      .menu-item {
        color: #222;
        font-size: 17px;
        font-weight: bold;
        margin-right: 18px;
        cursor: pointer;
        padding: 7px 10px;
        border-radius: 6px;
      }
      .menu-item.active {
        color: #186FDB;
        border-bottom: 2px solid #186FDB;
      }
      .header-right {
        margin-left: auto;
        display: flex;
        gap: 18px;
        align-items: center;
      }
      .header-ico {
        font-size: 20px;
        color: #444;
        background: #f8f8f8;
        border-radius: 50%;
        padding: 5px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 2px;
      }
      .header-avatar {
        width: 35px;
        height: 35px;
        background: #dbeafe;
        color: #2981ea;
        border-radius: 999px;
        display: flex;
        align-items: center; justify-content: center;
        font-size: 18px; font-weight: bold;
        margin-left: 10px;
      }
      .sap-overview {
        position: fixed;
        top: 90px; left: 2.3vw; z-index: 0;
        font-size: 2.0vw; font-weight: bold; color: #262f38;
        text-shadow: 0 1px 0 #fff;
        letter-spacing: 0;
        margin-bottom: 16px;
      }
      .sap-grey-bg {
        position: fixed;
        top: 125px;
        left: 0;
        width: 100vw;
        height: calc(100vh - 125px);
        background: linear-gradient(180deg,#F5F7F8 80%,#EDF0F1 100%);
        z-index: 0;
      }
      #jspsych-container,
      .app-container {
        width: 100vw;
        height: calc(100vh - 125px);
        overflow: hidden;
        position: relative;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

    .app-container {
      width: 100vw;
      height: calc(100vh - 125px);
      overflow: hidden;
      position: relative;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .app-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(4, 1fr);
      width: 100%;
      height: 100%;
      gap: 2.5vw;
      padding: 2.5vw;
      box-sizing: border-box;
      justify-items: center;
      align-items: center;
    }

    .app-box {
      aspect-ratio: 1 / 1;
      width: 100%;
      max-width: 9vw;
      max-height: 100%;
      background-color: white;
      border: 2px solid #ccc;
      border-radius: 1vw;
      box-shadow: 0.2vw 0.2vw 0.5vw rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      user-select: none;
      text-align: center;
      font-size: 1.6vw;
      transition: border 0.2s;
      z-index: 10;
      min-width: 0;
      min-height: 0;
    }

    .empty-app {
      background: #e4e8ec !important;
      border: 2px solid #bbb;
      cursor: pointer;
      transition: background 0.2s;
    }
    .app-box.empty-app:hover {
      background: #cdd8df !important;
    }
      .symbol {
        font-size: 2vw;
        color: #555;
      }
      .fixation-screen {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: white;
        font-size: 5vw;
      }
      .confirm-box {
        position: absolute;
        background-color: #fff;
        color: #1976d2;
        padding: 0.2vw 0.7vw;
        border-radius: 8px;
        font-size: 1vw;
        cursor: pointer;
        z-index: 20;
        border: 2px solid  #1976d2;
        font-weight: 500;
        box-shadow: none;
        font-family: inherit;
        width: 4vw;
        height: 2.2vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .highlight-target {
        border: 4px solid #888 !important;
        box-shadow: 0 0 12px #bbb !important;
      }
      /* NEUE CSS F√úR FEEDBACK */
      .correct-feedback-highlight-green {
        border: 4px solid #4CAF50 !important; /* Gr√ºner Rand */
        box-shadow: 0 0 15px rgba(76, 175, 80, 0.7) !important; /* Gr√ºner Glanz */
      }
      .feedback-text-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 3vw; 
        font-weight: bold;
        padding: 0.5vw 1vw;
        border-radius: 8px;
        z-index: 100; /* Sicherstellen, dass es √ºber allem anderen liegt */
        text-align: center;
        pointer-events: none; /* Sorgt daf√ºr, dass Klicks durchgehen */
        min-width: 100px; /* Mindestbreite, damit der Text gut sichtbar ist */
      }
      .feedback-text-overlay.correct {
        color: #4CAF50; /* Gr√ºner Text */
        background-color: rgba(232, 245, 233, 0.9); /* Leicht gr√ºner, halbtransparenter Hintergrund */
      }
      .feedback-text-overlay.incorrect {
        color: #F44336; /* Roter Text */
        background-color: rgba(255, 235, 238, 0.9); /* Leicht roter, halbtransparenter Hintergrund */
      }
      @media (max-width: 704px) {
        .sap-overview { font-size: 26px; }
        .app-box { font-size: 18px; }
        .symbol { font-size: 23px; }
        .confirm-box { font-size: 13px; width: 60px; height: 40px; }
        .app-grid { gap: 2vw; }
        .feedback-text-overlay { font-size: 26px; } /* Anpassung f√ºr mobile Ansicht */
      }

      /* NEUE CSS F√úR PRACTICE-BEREICH UND DENKBLASE */
      /* Diese Styles werden nur noch f√ºr den Hauptblock-Code verwendet, falls gew√ºnscht,
         oder ganz entfernt, wenn die Denkblase nur im √úbungsbereich auftaucht */
      .practice-area {
        display: flex;
        justify-content: center;
        align-items: flex-start;
        width: 100%;
        height: calc(100vh - 125px);
        box-sizing: border-box;
        padding: 20px;
        overflow: hidden;
      }

      .practice-area .app-container {
        width: 70%;
        height: 100%;
        position: relative; 
        flex-shrink: 0;
        margin-right: 2vw;
      }

      .thought-bubble {
        flex-grow: 1;
        max-width: 25%;
        background-color: #f8f8f8;
        border: 1px solid #ddd;
        border-radius: 12px;
        padding: 1.2vw 1.5vw;
        box-shadow: 0 2px 5px rgba(0,0,0,0.08);
        font-size: 1.1vw;
        line-height: 1.5;
        color: #333;
        z-index: 50;
        box-sizing: border-box;
        text-align: left;
        position: relative;
      }

      .thought-bubble::before {
        content: "";
        position: absolute;
        top: 20%;
        left: -18px;
        border-width: 10px;
        border-style: solid;
        border-color: transparent #ddd transparent transparent;
      }
      .thought-bubble::after {
        content: "";
        position: absolute;
        top: 20%;
        left: -16px;
        border-width: 9px;
        border-style: solid;
        border-color: transparent #f8f8f8 transparent transparent;
      }

      @media (max-width: 1024px) {
        .practice-area {
          flex-direction: column;
          align-items: center;
          overflow-y: auto;
          padding-top: 15px; 
        }
        .practice-area .app-container {
          width: 95%;
          height: auto;
          margin-right: 0;
          margin-bottom: 20px;
        }
        .thought-bubble {
          max-width: 95%;
          font-size: 16px;
          padding: 15px;
          margin-bottom: 20px;
        }
        .thought-bubble::before, .thought-bubble::after {
          display: none;
        }
      }

      /* Standard-Anleitungstext unter dem Grid ausblenden, wenn die Denkblase angezeigt wird */
      .practice-area .app-container + div[style*="margin-top:2em"] {
          display: none; 
      }
      /* Spezifische Klasse f√ºr einfachen Practice Stimulus, um die Denkblase auszublenden */
      .simple-practice-stimulus .app-container + div[style*="margin-top:2em"] {
        display: block !important; /* Zeigt den Anleitungstext wieder an */
        text-align: center; /* Zentriert den Text */
      }
      .simple-practice-stimulus .app-container {
        width: 100%; /* App-Container nimmt volle Breite ein, da keine Denkblase */
        margin-right: 0;
      }
    </style>
</head>
<body>
<div id="sap-bg">
  <div class="sap-header">
    <svg class="sap-logo" width="68" height="35" viewBox="0 0 68 35" xmlns="http://www.w3.org/2000/svg">
      <rect width="68" height="35" fill="#008FD3" />
    </svg>
    <span style="font-size:23px; margin-right:14px; cursor:pointer;">‚ò∞</span>
    <div class="header-menu">
      <span class="menu-item">Lunivox</span>
      <span class="menu-item">Trenola</span>
      <span class="menu-item active">Seraquix <span style="font-size:13px;">‚ñº</span></span>
    </div>
    <div class="header-right">
      <span class="header-ico">üîç</span>
      <span class="header-ico">üìç</span>
      <span class="header-ico">üéß</span>
      <span class="header-ico">‚ùì</span>
      <span class="header-ico">üîî</span>
      <span class="header-avatar">VM</span>
    </div>
  </div>
  <div class="sap-overview">Equao</div>
  <div class="sap-grey-bg"></div>
</div>
<!-- WICHTIG: tabindex="-1" hinzugef√ºgt, damit das DIV den Fokus empfangen kann -->
<div id="jspsych-container" style="position:absolute;top:125px;left:0;width:100vw;height:calc(100vh - 125px);z-index:10;" tabindex="-1"></div>
<script>
  // Erg√§nzungen gegen Scrollen/Window-Resizing
  window.addEventListener('scroll', function() { window.scrollTo(0,0); });
  document.body.style.overflow = 'hidden';
  document.documentElement.style.overflow = 'hidden';
</script>
<script>
  // ==== KONSTANTEN F√úR REAKTIONSTASTEN ====
  const KEY_TARGET_PRESENT = 'j';
  const KEY_TARGET_ABSENT = 'f';

  // NEUE KONSTANTE F√úR DIE BEST√ÑTIGUNGS-VERZ√ñGERUNG
  const CONFIRM_BUTTON_DELAY_MS = 60;
  // NEUE KONSTANTE F√úR FEEDBACK-DAUER IN √úBUNGSRUNDEN
  const FEEDBACK_DURATION_MS = 700; 


  // SAP-Hintergrund An/Aus helper
  function showSAPBackground(show = true) {
    const sapBg = document.getElementById('sap-bg');
    const jspsychContainer = document.getElementById('jspsych-container');

    if (show) { 
      // === STIL F√úR GRID-TRIALS (MIT SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = '';
      document.body.style.background = "#f5f6f7";
      if (jspsychContainer) {
        jspsychContainer.style.top = '125px';
        jspsychContainer.style.height = 'calc(100vh - 125px)';
      }
    } else { 
      // === STIL F√úR TEXT-TRIALS (OHNE SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = 'none';
      document.body.style.background = "white";
      if (jspsychContainer) {
        // Wir setzen den Container auf volle Bildschirmh√∂he
        jspsychContainer.style.top = '0px';
        jspsychContainer.style.height = '100vh';
      }
    }
  }

  // ==== KONSTANTEN ====
  const appNames = [
      "Limo7", "Loru7", "HivoN", "HoruN", 
      "PikaX", "PoliX", "Pansi2", "Pexi2", 
      "MenoL", "MuniL", "Fexa5", "Fumi5",
      "Venni9", "Vabo9", "Vuma3", "Vezu3",
      "SuniX", "SokuX", "Samr7", "Seda7",
      "RafiQ", "RibuQ", "RapoM", "RenuM",
      "Keso2", "Kipu2", "KanoL", "KuraL", 
      "KariQ", "KesoQ"
    ];
  const symbols = [
    '‚ñ≤\uFE0E',  '‚ñ†\uFE0E',  '‚óè\uFE0E',  '‚óÜ\uFE0E',  '‚òÖ\uFE0E',  '‚úö\uFE0E', '‚òÄ\uFE0E', '‚òÅ\uFE0E', '‚ôû\uFE0E'
  ];

  // ==== JSPSYCH INIT ====
  const jsPsych = initJsPsych({
    display_element: 'jspsych-container',
    on_finish: function() {
        // Daten als CSV herunterladen
        jsPsych.data.get().localSave('csv', 'sap_app_task_data.csv', {
            exclude_columns: ['timeout', 'failed_images', 'failed_video', 'failed_audio']
        });

        // Optional: Eine "Danke"-Nachricht anzeigen, damit der Teilnehmer wei√ü, dass das Experiment beendet ist.
        document.getElementById('jspsych-container').innerHTML = `
            <div style="max-width: 900px; margin: 0 auto; text-align: center; padding-top: 100px;">
                <h2>Vielen Dank f√ºr Ihre Teilnahme!</h2>
                <p>Ihre Daten wurden automatisch gespeichert.</p>
                <p>Sie k√∂nnen das Fenstern nun schlie√üen.</p>
            </div>
        `;
        // Stellen Sie sicher, dass der SAP-Hintergrund f√ºr die Danke-Nachricht ausgeblendet ist
        showSAPBackground(false);
    }
  });

  // ==== BLOCKS UND PROBE-TYPEN DEFINITION ====
  const trialsPerBlock = 120; 

  function generateBlockConditions(numTrials) {
      const conditions = [];
      const targetPresentCount = numTrials / 2; // 60
      const targetAbsentCount = numTrials / 2;  // 60

      const probeDistribution = {
          'on-probe': 0.40, // 40%
          'off-probe': 0.40, // 40%
          'no-probe': 0.20  // 20%
      };

      const addConditions = (isTargetPresent, count) => {
          let currentCount = 0;
          let tempConditions = [];
          for (const probeType in probeDistribution) {
              let numType = Math.round(count * probeDistribution[probeType]);
              if (currentCount + numType > count) {
                  numType = count - currentCount;
              }
              for (let i = 0; i < numType; i++) {
                  tempConditions.push({
                      isTargetPresent: isTargetPresent,
                      probeType: probeType
                  });
              }
              currentCount += numType;
          }
          // Adjust for any remaining rounding errors after initial distribution
          while (currentCount < count) {
              tempConditions.push({ isTargetPresent: isTargetPresent, probeType: jsPsych.randomization.sampleWithoutReplacement(Object.keys(probeDistribution), 1)[0] });
              currentCount++;
          }
          while (currentCount > count) {
              const idxToRemove = tempConditions.findIndex(c => c.isTargetPresent === isTargetPresent);
              if (idxToRemove !== -1) {
                  tempConditions.splice(idxToRemove, 1);
              }
              currentCount--;
          }
          conditions.push(...tempConditions);
      };

      addConditions(true, targetPresentCount);
      addConditions(false, targetAbsentCount);

      return jsPsych.randomization.shuffle(conditions);
  }

  let block1Conditions = generateBlockConditions(trialsPerBlock);
  let block2Conditions = generateBlockConditions(trialsPerBlock);

  const preload = {
    type: jsPsychPreload,
    images: [],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true)
  };

  const startPage = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div style="max-width: 900px; margin: 0 auto; text-align: left;">
        <h2>Willkommen zum Experiment</h2>
        <p>Das Experiment wird ungef√§hr 30 Minuten dauern. Bitte stellen Sie sicher, dass sie w√§hrend dieser Zeit nicht gest√∂rt werden.</p>
        <p>Es wird empfohlen, das Experiment an einem Laptop / Computer oder an einem Tablet mit angeschlossener Tastatur durchzuf√ºhren.</p>
        <p>In diesem Experiment sehen Sie Raster mit App-Kacheln. Zu Beginn jedes Blocks wird Ihnen eine Ziel-App gezeigt. Ihre 
          Aufgabe ist es, die Ziel-App im nachfolgenden Raster so schnell wie m√∂glich zu entdecken und auf sie zu reagieren:</p>
        <ul style="margin: 20px 0 20px 20px; padding-left: 20px;">
            <li>Dr√ºcken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken.</li>
            <li>Dr√ºcken Sie die Taste <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass die Ziel-App nicht vorhanden ist.</li>
        </ul>
        <p>Anschlie√üend erscheint normalerweise ein Feld ‚ÄûBest√§tigen‚Äú, bei dem Sie mit der Taste <b>${KEY_TARGET_PRESENT.toUpperCase()} 
          oder ${KEY_TARGET_ABSENT.toUpperCase()}</b> so schnell wie m√∂glich reagieren sollen. 
          In einigen F√§llen erscheint das "Best√§tigen"-Feld jedoch nicht, und der Trial endet direkt nach Ihrem ersten Tastendruck. 
          Bei diesen Trials wird das App-Raster noch f√ºr ca. 1,5s angezeigt, dann geht das n√§chste Trial automatisch los.
          Es ist wichtig, dass Sie in dieser Situation nur mit Tastendruck auf die Ziel-App reagieren und bei Nichterscheinen des 
          Best√§tigen-Feldes KEINE Taste dr√ºcken.</p>
        <p style="text-align: center; margin-top: 30px;">Dr√ºcken Sie eine <b>beliebige Taste</b>, um zu beginnen.</p>
      </div>
    `,
    choices: "ALL_KEYS",
    css_classes: ['vertically-centered-content'],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true),
    data: { trial_stage: 'instruction', block_type: 'Einleitung' }
};

  function getFixationTrial(blockType = 'unknown') {
    return {
      type: jsPsychHtmlButtonResponse, // Hier kann es bleiben, da keine Tastaturantwort erwartet wird
      stimulus: '<div style="display:flex; justify-content:center; align-items:center; width:100%; height:100%; font-size: 50px; color: black; background: transparent;">+</div>', // Zentriertes '+' auf transparentem Hintergrund
      choices: [],
      trial_duration: 1000, // 1000ms Fixation
      response_ends_trial: false, 
      on_load: () => showSAPBackground(true), // Sicherstellen, dass SAP Hintergrund angezeigt wird
      on_finish: () => showSAPBackground(true), // Sicherstellen, dass SAP Hintergrund sichtbar bleibt
      data: { trial_stage: 'fixation', block_type: blockType }
    };
  }

  function getShowTarget(targetApp, highlight, blockType) {
      return {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => `
          <div style="max-width:900px; margin:0 auto; text-align:center;">
            <p><b>Dies ist die Ziel-App f√ºr die n√§chsten Trials.</b><br>
            Merken Sie sich Name und Symbol!</p>
            <p> Es gibt w√§hrend der n√§chsten Trials kein Feedback f√ºr die richtige Aushwahl der Ziel-App oder "Best√§tigen" Button Position, ob Ihre Wahl richtig 
              oder falsch war wird aber dennoch vermerkt.</p>
            <div style="display:flex; justify-content:center;">
              <div class="app-box${highlight ? ' highlight-target' : ''}" style="width:9vw; display:inline-flex;">
                ${targetApp.name}<div class="symbol">${targetApp.symbol}</div>
              </div>
            </div>
            <p style="margin-top: 30px;">Dr√ºcken Sie die <b>Leertaste</b>, um fortzufahren.</p>
          </div>`,
          choices: [' '], 
        css_classes: ['vertically-centered-content'],
        on_load: () => showSAPBackground(false),
        on_finish: () => showSAPBackground(true),
        data: { trial_stage: 'show_target', target_app_name: targetApp.name, target_app_symbol: targetApp.symbol, block_type: blockType }
      };
    }

    function getInstructions(blockName, highlight, blockType) {
    const step2_instruction_present = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe immer <b>mit einem dunkelgrauen Rahmen markiert</b>.`
      : `Finden Sie die Ziel-App im Raster.`;
    const step2_instruction_absent = `Stellen Sie fest, ob die Ziel-App nicht vorhanden ist.`;

    const stimulus_html = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">${blockName}</h2>
        <p>In diesem Block sehen Sie in mehreren Durchg√§ngen ein Raster mit Apps. Ihre Aufgabe ist es, in jedem Durchgang die folgenden Schritte so schnell und genau wie m√∂glich auszuf√ºhren:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Pr√§gen Sie sich die <b>Ziel-App</b> ein, die Ihnen zu Beginn und bei einem Wechsel angezeigt wird.</li>
          <li style="margin-bottom: 15px;">${step2_instruction_present} Dr√ºcken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken.</li>
          <li style="margin-bottom: 15px;">${step2_instruction_absent} Dr√ºcken Sie die Taste <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass die Ziel-App nicht vorhanden ist.</li>
          <li style="margin-bottom: 15px;">Ein Feld mit "<b>Best√§tigen</b>" erscheint an einer zuf√§lligen Stelle. Reagieren Sie darauf ebenfalls so schnell wie m√∂glich mit der <b>Taste ${KEY_TARGET_PRESENT.toUpperCase()} oder ${KEY_TARGET_ABSENT.toUpperCase()}</b>. Manchmal wird das "Best√§tigen"-Feld jedoch nicht erscheinen. Bei diesen Trials wird das App-Raster noch f√ºr 3 Sekunden angezeigt, um Ihre Aufmerksamkeit zu √ºberpr√ºfen.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">Dr√ºcken Sie eine <b>beliebige Taste</b>, um fortzufahren.</p>
      </div>
    `;

    return {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: stimulus_html,
      choices: "ALL_KEYS",
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'block_instruction', block_name_display: blockName, block_type: blockType }
    };
  }

  function renderLayoutRandomGrid(apps, highlightTarget) {
  // Erzeuge 4x4 Positionen
  let positions = [];
  for (let row = 1; row <= 4; row++) {
    for (let col = 1; col <= 4; col++) {
      positions.push({ row, col });
    }
  }
  // shuffle positions
  for (let i = positions.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [positions[i], positions[j]] = [positions[j], positions[i]];
  }
  // benutze nur so viele Positionen wie Apps geliefert wurden (z.B. 8 oder 4)
  let usedPositions = positions.slice(0, apps.length);

  // baue HTML; die app-boxen behalten die vorhandenen CSS-Klassen
  let html = `<div class="app-grid">`;
  usedPositions.forEach((pos, idx) => {
    let app = apps[idx];
    let targetClass = (highlightTarget && app.isTarget) ? " highlight-target" : "";
    html += `<div id="app-${idx}" class="app-box${targetClass}" 
              style="grid-row: ${pos.row}; grid-column: ${pos.col};" data-app-name="${app.name}">
              ${app.name}<div class="symbol">${app.symbol}</div>
            </div>`;
  });
  html += "</div>";
  return html;
}

  const layoutRenderers = [renderLayoutRandomGrid];
  const layoutNames = ["RandomGrid4x6"];

  // makeSearchTrial jetzt f√ºr alle Such-Trials (√úbungs- und Haupt-Trials)
  function getSearchTrial(apps, highlightTarget, blockLabel, probeType, blockType, isTargetPresent) {
    const randomIndex = Math.floor(Math.random() * layoutRenderers.length);
    const renderer = layoutRenderers[randomIndex];
    const layoutName = layoutNames[randomIndex];
    
    const currentTrialProbeType = probeType; 
    const expectedKey = isTargetPresent ? KEY_TARGET_PRESENT : KEY_TARGET_ABSENT;

    return {
      type: jsPsychHtmlKeyboardResponse, // *** JETZT KONSEQUENT KEYBOARDRESPONSE ***
      stimulus: () => {
        let stimulusHTML;
        let instructionTextBelowGrid = isTargetPresent 
            ? `<b>Dr√ºcken Sie die Taste ${KEY_TARGET_PRESENT.toUpperCase()}, sobald Sie die Ziel-App entdeckt haben!</b>`
            : `<b>Dr√ºcken Sie die Taste ${KEY_TARGET_ABSENT.toUpperCase()}, sobald Sie festgestellt haben, dass die Ziel-App NICHT vorhanden ist!</b>`;

        // Unterscheide zwischen √úbungs- und Haupttrials f√ºr den Stimulus-Aufbau
        if (blockType === '√úbung') {
            // *** TEMPOR√ÑR VEREINFACHTER STIMULUS F√úR √úBUNGSTRIALS ZUM DEBUGGING ***
            const keyPresentText = KEY_TARGET_PRESENT.toUpperCase();
            const keyAbsentText = KEY_TARGET_ABSENT.toUpperCase();
            
            let presenceInstruction = isTargetPresent 
              ? `Die Ziel-App ist <b>vorhanden</b>. Dr√ºcke <b>${keyPresentText}</b>.` 
              : `Die Ziel-App ist <b>NICHT vorhanden</b>. Dr√ºcke <b>${keyAbsentText}</b>.`;

            stimulusHTML = `
                <div class="app-container simple-practice-stimulus">
                    ${renderer(apps, highlightTarget)}
                    <div style="margin-top:2em; font-size:1.2vw; color:#333; text-align: center;">
                        ${presenceInstruction}
                        <br>
                        Danach erscheint der "Best√§tigen"-Button.
                    </div>
                </div>
            `;
        } else {
            // Originaler Stimulus f√ºr Hauptbl√∂cke (nicht √úbung)
            stimulusHTML = `
                <div class="app-container">
                    ${renderer(apps, highlightTarget)}
                </div>
                <div style="margin-top:2em; font-size:1.2vw; color:#333;">${instructionTextBelowGrid}</div>
            `;
        }
        return stimulusHTML;
      },
      choices: [KEY_TARGET_PRESENT, KEY_TARGET_ABSENT], // *** HIER RICHTIGE CHOICES F√úR KEYBOARDRESPONSE ***
      response_ends_trial: false, // *** WICHTIG: Trial nicht sofort beenden ***
      data: { 
        trial_stage: 'search_task', 
        block_type: blockType, 
        original_block_label: blockLabel,
        is_target_highlighted: highlightTarget, 
        layout: layoutName,
        probe_type: currentTrialProbeType,
        is_target_present: isTargetPresent,
        expected_key_search: expectedKey 
      }, 
      on_load: (trial) => {
        console.log(`[Trial ${blockLabel}] Loaded. Target present: ${isTargetPresent}.`); // Debugging
        showSAPBackground(true);
        // Fokus auf den jspsych-container setzen
        const jspsychContainer = document.getElementById('jspsych-container');
        if (jspsychContainer) {
            jspsychContainer.focus();
            console.log('[Trial] jspsych-container focused.'); // Debugging
        } else {
            console.warn('[Trial] jspsych-container not found for focusing.'); // Debugging
        }

        window.currentGridApps = apps.map(x => ({...x}));
        window.appRects = [];
        document.querySelectorAll('.app-box').forEach((box, i) => {
          const el = box.getBoundingClientRect();
          window.appRects.push({
            name: window.currentGridApps[i].name,
            x: el.left,
            y: el.top,
            width: el.width,
            height: el.height,
            isTarget: window.currentGridApps[i].isTarget
          });
        });
        window.appScreenStart = performance.now();
      },
      on_response: (info) => { // *** on_response F√úR KEYBOARDRESPONSE ***
        console.log(`[Trial ${blockLabel}] === ON_RESPONSE TRIGGERED === Key: ${info.key}, RT: ${info.rt}`); // Debugging
        const pressedKey = info.key;
        const rt_select = info.rt; // Reaktionszeit kommt direkt von JsPsych

        const isResponseCorrect = (pressedKey === expectedKey);

        let appRect = null;
        let targetAppElement = null; 
        if (isTargetPresent) { 
            const targetIdx = apps.findIndex(a => a.isTarget);
            if (targetIdx !== -1) {
                targetAppElement = document.getElementById('app-' + targetIdx); 
                if (targetAppElement) appRect = targetAppElement.getBoundingClientRect();
            }
        }
        window.appPosition = appRect ? { x: appRect.left, y: appRect.top, width: appRect.width, height: appRect.height } : null;

        const searchPhaseData = {
            rt_select: rt_select,
            response_key_search: pressedKey, 
            is_response_correct_search: isResponseCorrect, 
            app1_position_x: window.appPosition ? window.appPosition.x : null,
            app1_position_y: window.appPosition ? window.appPosition.y : null,
        };

        // Hier beginnt die Logik, wie es nach dem ersten Tastendruck weitergeht
        if (blockType === '√úbung') {
            // In √úbungsrunden immer Feedback und immer Best√§tigungs-Button
            const feedbackDiv = document.createElement('div');
            feedbackDiv.className = 'feedback-text-overlay';
            
            if (isResponseCorrect) {
                feedbackDiv.textContent = 'Richtig';
                feedbackDiv.classList.add('correct'); 
                if (isTargetPresent && targetAppElement) { 
                   targetAppElement.classList.add('correct-feedback-highlight-green');
                }
            } else {
                feedbackDiv.textContent = 'Falsch';
                feedbackDiv.classList.add('incorrect'); 
            }
            
            document.body.appendChild(feedbackDiv);
            console.log(`[Trial ${blockLabel}] Feedback displayed (${feedbackDiv.textContent}). Scheduling confirm button.`); // Debugging

            setTimeout(() => {
                feedbackDiv.remove(); 
                if (targetAppElement) { 
                    targetAppElement.classList.remove('correct-feedback-highlight-green');
                }
                console.log(`[Trial ${blockLabel}] Feedback removed. Calling showConfirmButton.`); // Debugging
                setTimeout(() => showConfirmButton((confirmData) => jsPsych.finishTrial({ ...searchPhaseData, ...confirmData }), true, 'on-probe'), CONFIRM_BUTTON_DELAY_MS);
            }, FEEDBACK_DURATION_MS);

        } else { // Haupt-Trials (Test-Block, Baseline-Block)
            if (currentTrialProbeType === 'no-probe') {
                console.log(`[Trial ${blockLabel}] No-probe trial. Finishing after 1.5s.`); // Debugging
                setTimeout(() => { 
                    jsPsych.finishTrial({
                        ...searchPhaseData,
                        confirm_position_x: null, 
                        confirm_position_y: null, 
                        rt_confirm: null,         
                        response_key_confirm: null, 
                        probe_type: currentTrialProbeType,
                        confirm_tries: null       
                    });
                }, 1500); // Angepasste Dauer f√ºr no-probe Trials, um 1,5s anzuzeigen.
            } else {
                console.log(`[Trial ${blockLabel}] Probe trial. Scheduling confirm button.`); // Debugging
                setTimeout(() => showConfirmButton((confirmData) => { 
                  const confirmPosition = window.confirmPosition; 
                  jsPsych.finishTrial({ 
                    ...searchPhaseData,
                    confirm_position_x: confirmPosition ? confirmPosition.x : null,
                    confirm_position_y: confirmPosition ? confirmPosition.y : null,
                    ...confirmData 
                  });
                }, false, currentTrialProbeType), CONFIRM_BUTTON_DELAY_MS); 
            }
        }
      },
      on_unload: () => { 
        console.log(`[Trial ${blockLabel}] Trial unloaded.`); 
      }
    };
  }


  // ==== PRACTICE BLOCK ====
  const totalPracticeTrials = 8; 

  function makePracticeBlock(highlight) {
    const step2_instruction = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe <b>mit einem dunkelgrauen Rahmen markiert</b>.`
      : `Finden Sie die Ziel-App im Raster.`;

    const practiceInstructionStimulus = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">√úbungsrunde</h2>
        <p>Wir beginnen mit einer kurzen √úbungsrunde mit ${totalPracticeTrials} Durchg√§ngen, um den Ablauf kennenzulernen. Bitte f√ºhren Sie die folgenden Schritte so schnell und genau wie m√∂glich aus:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Pr√§gen Sie sich die <b>Ziel-App</b> ein, die Ihnen zu Beginn gezeigt wird.</li>
          <li style="margin-bottom: 15px;">${step2_instruction} Dr√ºcken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken, oder <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass sie nicht vorhanden ist.</li> 
          <li style="margin-bottom: 15px;">Ein Feld mit "<b>Best√§tigen</b>" erscheint. Reagieren Sie darauf ebenfalls so schnell wie m√∂glich mit der <b>Taste ${KEY_TARGET_PRESENT.toUpperCase()} oder ${KEY_TARGET_ABSENT.toUpperCase()}</b>.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">In der √úbungsrunde wird das "Best√§tigen"-Feld immer erscheinen. Die Ziel-App wird abwechselnd vorhanden und nicht vorhanden sein. Bei korrekter Antwort erhalten Sie ein kurzes Feedback.</p>
        <p style="margin-top: 30px;">Dr√ºcken Sie eine <b>beliebige Taste</b>, um die √úbung zu beginnen.</p>
      </div>
    `;

    const practiceInstructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: practiceInstructionStimulus,
      choices: "ALL_KEYS",
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'practice_instruction', block_type: '√úbung' }
    };

    const practice_timeline = [practiceInstructions];

    const practiceTargetApp = {
        name: jsPsych.randomization.sampleWithoutReplacement(appNames, 1)[0],
        symbol: symbols[Math.floor(Math.random() * symbols.length)]
    };
    
    practice_timeline.push(getShowTarget(practiceTargetApp, highlight, '√úbung'));

    for (let i = 0; i < totalPracticeTrials; i++) {
        const isTargetPresentTrial = (i % 2 === 0); 
        // Jetzt getSearchTrial f√ºr √úbungstrials verwenden
        let practiceApps = [];
        const tempDistractorPool = appNames.filter(name => name !== practiceTargetApp.name);
        let distractors;

        if (isTargetPresentTrial) {
            distractors = jsPsych.randomization.sampleWithoutReplacement(tempDistractorPool, 3);
            practiceApps = distractors.map(name => ({name: name, symbol: symbols[Math.floor(Math.random() * symbols.length)], isTarget: false}));
            practiceApps.push({name: practiceTargetApp.name, symbol: practiceTargetApp.symbol, isTarget: true});
        } else {
            distractors = jsPsych.randomization.sampleWithoutReplacement(tempDistractorPool, 4);
            practiceApps = distractors.map(name => ({name: name, symbol: symbols[Math.floor(Math.random() * symbols.length)], isTarget: false}));
        }
        practiceApps = jsPsych.randomization.shuffle(practiceApps);

        practice_timeline.push(getFixationTrial('√úbung'));
        practice_timeline.push(getSearchTrial(
            practiceApps,
            highlight,
            `√úbungstrial ${i + 1}`,
            'on-probe', // In √úbungstrials immer on-probe f√ºr den Best√§tigen-Button
            '√úbung',
            isTargetPresentTrial
        ));
    }

    const endPractice = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="font-size: 20px; text-align: center; max-width: 800px; margin: 0 auto;">
          <p>Die √úbungsrunde ist beendet.</p>
          <p>Der Hauptblock beginnt jetzt.</p>
          <p style="margin-top: 30px;">Dr√ºcken Sie eine <b>beliebige Taste</b>, um fortzufahren.</p>
        </div>
      `,
      choices: "ALL_KEYS",
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'practice_end', block_type: '√úbung' }
    };
    practice_timeline.push(endPractice);

    return practice_timeline;
  }

  const numTargetsPerExperiment = 12; 
  const allExperimentTargetNames = jsPsych.randomization.sampleWithoutReplacement(appNames, numTargetsPerExperiment);

  // Der globalDistractorPool enth√§lt alle App-Namen, die NIEMALS Ziel-Apps sein werden (weder jetzt noch sp√§ter)
  const globalDistractorPool = appNames.filter(name => !allExperimentTargetNames.includes(name));

  function makeBlockTrials(highlight, blockLabel, trialConditionsArr, blockOrderNumber) { 
    const block = [];
    
    const displayBlockName = `Block ${blockOrderNumber}`;
    block.push(getInstructions(displayBlockName, highlight, blockLabel)); 
    
    // √úbungsblock wird hier nicht mehr eingef√ºgt, da er global am Anfang der Timeline ist.
    // block.push(...makePracticeBlock(highlight)); 

    let targetsForThisBlockNames;
    if (blockOrderNumber === 1) {
        targetsForThisBlockNames = allExperimentTargetNames.slice(0, 6); 
    } else { 
        targetsForThisBlockNames = allExperimentTargetNames.slice(6, 12); 
    }
    
    const blockTargets = targetsForThisBlockNames.map(name => ({ 
        name: name, 
        symbol: symbols[Math.floor(Math.random() * symbols.length)] 
    }));

    let currentTargetIdx = 0;
    block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel)); 

    for (let i = 0; i < trialsPerBlock; i++) { 
      if (i > 0 && i % 20 === 0) { 
        currentTargetIdx = (currentTargetIdx + 1) % blockTargets.length; 
        block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel)); 
      }
      
      const currentCondition = trialConditionsArr[i]; 
      let currentTarget = blockTargets[currentTargetIdx]; 

      let gridAppsNames;
      const numAppsInGrid = 8; 

      if (currentCondition.isTargetPresent) {
          const availableDistractors = globalDistractorPool.filter(name => name !== currentTarget.name);
          gridAppsNames = jsPsych.randomization.sampleWithoutReplacement(availableDistractors, numAppsInGrid - 1);
          gridAppsNames.push(currentTarget.name); 
      } else {
          const availableDistractors = globalDistractorPool.filter(name => name !== currentTarget.name);
          gridAppsNames = jsPsych.randomization.sampleWithoutReplacement(availableDistractors, numAppsInGrid); 
      }

      let gridApps = jsPsych.randomization.shuffle(gridAppsNames).map(name => ({
        name: name,
        symbol: (currentCondition.isTargetPresent && name === currentTarget.name) 
                  ? currentTarget.symbol 
                  : symbols[Math.floor(Math.random() * symbols.length)],
        isTarget: (currentCondition.isTargetPresent && name === currentTarget.name)
      }));

      block.push(getFixationTrial(blockLabel)); 
      block.push(getSearchTrial( // *** HIER WIRD AUCH GETSEARCHTRIAL VERWENDET ***
        gridApps,
        highlight,
        blockLabel,
        currentCondition.probeType, 
        blockLabel,
        currentCondition.isTargetPresent 
      ));
    }
    return block;
  }


  function getRectDistance(rect1, rect2) {
      const r1 = {x1: rect1.x, y1: rect1.y, x2: rect1.x + rect1.width, y2: rect1.y + rect1.height};
      const r2 = {x1: rect2.x, y1: rect2.y, x2: rect2.x + rect2.width, y2: rect2.y + rect1.height}; 
      const dx = Math.max(0, r1.x1 - r2.x2, r2.x1 - r1.x2);
      const dy = Math.max(0, r1.y1 - r2.y2, r2.y1 - r1.y2);
      return Math.sqrt(dx * dx + dy * dy);
  }

  function getOverlapArea(rect1, rect2) {
      const x_overlap = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x));
      const y_overlap = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
      return x_overlap * y_overlap;
  }


  const showConfirmButton = (callback, isPractice = false, probeType = null) => {
  console.log(`[Confirm Button] Called with isPractice: ${isPractice}, probeType: ${probeType}`); // Debugging

  if (probeType === 'no-probe') {
    callback({
      rt_confirm: null,
      response_key_confirm: null,
      probe_type: probeType,
      confirm_tries: 0,
      confirm_position_x: null,
      confirm_position_y: null
    });
    return;
  }

  const confirm = document.createElement('div');
  confirm.className = 'confirm-box';
  confirm.textContent = 'Best√§tigen';

  const paddingY = window.innerHeight * 0.05;
  const paddingX = window.innerWidth * 0.05;

  const minimumTopInPixels = 140;
  const topBoundary = Math.max(minimumTopInPixels, window.innerHeight * 0.10);
  const bottomBoundary = window.innerHeight - paddingY;
  const leftBoundary = paddingX;
  const rightBoundary = window.innerWidth - paddingX;

  // Tempor√§re Platzierung, um Gr√∂√üe zu messen
  confirm.style.position = 'absolute';
  confirm.style.left = '-1000px';
  confirm.style.top = '-1000px';
  document.body.appendChild(confirm);

  const buttonW = confirm.offsetWidth;
  const buttonH = confirm.offsetHeight;
  const buttonArea = buttonW * buttonH;

  // *** HIER IST DIE ANPASSUNG F√úR DIE GRENZE DES BEST√ÑTIGEN-BUTTONS ***
  // Vermeide die √§u√üerste rechte Bildschirmzone: 15% der Breite oder mindestens 100px
  const avoidRightPx = Math.max(100, Math.round(window.innerWidth * 0.15)); // 15% statt 12%
  let rightBoundaryUsed = rightBoundary - avoidRightPx;

  // Fallback, falls der m√∂gliche Bereich zu eng wird (z.B. wenn der Bildschirm sehr schmal ist)
  if (rightBoundaryUsed - leftBoundary - buttonW < 20) { 
    rightBoundaryUsed = rightBoundary - buttonW; 
  }
  // *** ENDE DER ANPASSUNG ***

  // probeType sicherstellen
  if (isPractice && !probeType) {
    probeType = 'on-probe'; 
  } else if (!isPractice && !probeType) {
    console.error("showConfirmButton wurde ohne probeType im Haupt-Trial aufgerufen. Using fallback 'off-probe'.");
    probeType = 'off-probe';
  }

  let confirmX = leftBoundary; 
  let confirmY = topBoundary; 
  let tries = 0;
  let found = false;

  const rects = window.appRects || [];
  const nonTargetRects = rects.filter(r => !r.isTarget);
  const targetRect = rects.find(r => r.isTarget);

  while (tries < 1000 && !found) {
    const minX = leftBoundary;
    const maxX = Math.max(minX, rightBoundaryUsed - buttonW); 
    if (maxX <= minX) {
      confirmX = leftBoundary + Math.random() * (rightBoundary - leftBoundary - buttonW);
    } else {
      confirmX = minX + Math.random() * (maxX - minX);
    }
    confirmY = topBoundary + Math.random() * (bottomBoundary - topBoundary - buttonH);

    const currentConfirmRect = { x: confirmX, y: confirmY, width: buttonW, height: buttonH };

    if (probeType === 'on-probe') {
      let hasSufficientOverlapWithNonTarget = false;
      for (const rect of nonTargetRects) {
        const overlap = getOverlapArea(currentConfirmRect, rect);
        if (overlap / buttonArea >= 0.75) {
          hasSufficientOverlapWithNonTarget = true;
          break;
        }
      }

      let overlapsTarget = false;
      if (targetRect) {
        const overlapTarget = getOverlapArea(currentConfirmRect, targetRect);
        if (overlapTarget > 0.001) overlapsTarget = true;
      }

      if (hasSufficientOverlapWithNonTarget && !overlapsTarget) found = true;
    } else {
      let anyOverlap = false;
      let tooCloseToApps = false;
      for (const rect of rects) {
        const overlap = getOverlapArea(currentConfirmRect, rect);
        if (overlap > 0.001) {
          anyOverlap = true;
          break;
        }
        const dist = getRectDistance(currentConfirmRect, rect);
        if (dist < window.innerWidth * 0.02) {
          tooCloseToApps = true;
          break;
        }
      }
      if (!anyOverlap && !tooCloseToApps) found = true;
    }
    tries++;
  }

  if (!found) {
    console.warn(`[Confirm Button] Konnte keine optimale Position f√ºr den 'Best√§tigen'-Button (${probeType}) nach ${tries} Versuchen finden. Platzierung k√∂nnte suboptimal sein.`);
  }

  confirm.style.left = `${confirmX}px`;
  confirm.style.top = `${confirmY}px`;
  document.body.appendChild(confirm); 
  console.log(`[Confirm Button] Button appended to body at x: ${confirmX}, y: ${confirmY}`); // Debugging


  let confirmKeyListener = null; 
  let confirmFinished = false;

  confirmKeyListener = (e) => {
    const pressedKey = e.key.toLowerCase();
    if (pressedKey === KEY_TARGET_PRESENT || pressedKey === KEY_TARGET_ABSENT) {
      e.preventDefault();
      if (!confirmFinished) {
        confirmFinished = true;
        const rt_confirm = performance.now() - window.confirmAppearTime;
        const dataToReturn = {
          rt_confirm: rt_confirm,
          response_key_confirm: pressedKey,
          probe_type: probeType,
          confirm_tries: tries
        };
        confirm.remove();
        document.removeEventListener('keydown', confirmKeyListener, true); 
        confirmKeyListener = null; 
        console.log(`[Confirm Button] Key pressed: ${pressedKey}. Confirm finished. Calling callback.`); // Debugging
        callback(dataToReturn);
      }
    }
  };
  document.addEventListener('keydown', confirmKeyListener, true); 
};


  // === Timeline ===
  const block_definitions = [
    { highlight: false, label: "Test-Block", conditions: block1Conditions }, 
    { highlight: true, label: "Baseline-Block", conditions: block2Conditions } 
  ];

  const randomized_blocks = jsPsych.randomization.shuffle(block_definitions);

  // Der √úbungsblock wird nur einmal ganz am Anfang der Timeline eingef√ºgt
  const practiceBlockTimeline = makePracticeBlock(randomized_blocks[0].highlight); 

  const firstBlock = makeBlockTrials(
    randomized_blocks[0].highlight,
    randomized_blocks[0].label,
    randomized_blocks[0].conditions, 
    1 
  );

  const secondBlock = makeBlockTrials(
    randomized_blocks[1].highlight,
    randomized_blocks[1].label,
    randomized_blocks[1].conditions, 
    2 
  );
  
  // Die Haupt-Timeline des Experiments
  const timeline = [preload, startPage, ...practiceBlockTimeline, ...firstBlock, ...secondBlock];

  jsPsych.run(timeline);
</script>
</body>
</html>