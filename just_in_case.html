<!DOCTYPE html>
<html>
<head>
  <title>Mein Experiment</title>
  <script src="https://unpkg.com/jspsych@7.3.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.2"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.2"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-likert@1.1.2"></script>
  <link href="https://unpkg.com/jspsych@7.3.3/css/jspsych.css" rel="stylesheet" type="text/css">
  <style>
    .jspsych-display-element {
      font-size: 16px;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(5, 100px);
      grid-template-rows: repeat(3, 100px);
      gap: 10px;
      justify-content: center;
      align-items: center;
    }
    .grid-item {
      width: 90px;
      height: 90px;
      border: 2px solid #333;
      border-radius: 15px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      cursor: pointer;
      background-color: #f0f0f0;
      transition: background-color 0.1s;
    }
    .grid-item:hover {
      background-color: #e0e0e0;
    }
    .grid-item.highlight {
       background-color: #add8e6; /* Hellblau für Highlight */
    }
    .grid-item.practice-feedback {
       border: 3px solid green;
    }
    .app-name {
      font-weight: bold;
      font-size: 1.1em;
    }
    .app-symbol {
      font-size: 2em;
      line-height: 1;
    }
    .instructions, .show-target {
      max-width: 800px;
      margin: auto;
      text-align: left;
    }
    .memory-check-container {
      display: flex;
      justify-content: center;
      gap: 20px;
    }
    .memory-check-option {
      width: 120px;
      height: 120px;
      border: 2px solid #333;
      border-radius: 15px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      background-color: #f0f0f0;
    }
  </style>
</head>
<body>
  <div id="jspsych-target"></div>
  <script>
    const jsPsych = initJsPsych({
      on_finish: function() {
        jsPsych.data.displayData('csv');
      }
    });

    // ==== KONSTANTEN ====
    const totalTrials = 72;
    const trialsPerBlock = totalTrials / 2;

    const appNames = [
      "Limo7", "LiloM", "PikaX", "Pansi2", "MenoL",
      "Melo0", "Venni9", "Vuma3", "SuniX", "Samr7",
      "RafiQ", "RapoM", "Keso2", "KanoL", "KariQ",
      "ZenoX", "ZyloP", "Fexa5", "Brivo1", "QuiloT",
      "JunoS", "HivoN", "GryfA" // 23 Namen, sicher für das aktuelle Design
    ];
    const symbols = [
      '▲\uFE0E',  '■\uFE0E',  '●\uFE0E',  '◆\uFE0E',  '★\uFE0E',  '✚\uFE0E', '☀\uFE0E', '☁\uFE0E', '♞\uFE0E'
    ];
    
    // NEUE KONSTANTE für die Flexibilität
    const TRIALS_PER_TARGET = 10;

    const probeArrBlock1 = Array(trialsPerBlock).fill(0).map(() => Math.random() < 0.2 ? 'probe' : 'non-probe');
    const probeArrBlock2 = Array(trialsPerBlock).fill(0).map(() => Math.random() < 0.2 ? 'probe' : 'non-probe');

    const fixation = {
      type: jsPsych.HtmlKeyboardResponse,
      stimulus: '<div style="font-size:60px;">+</div>',
      choices: "NO_KEYS",
      trial_duration: 500
    };

    const preload = {
      type: jsPsych.Preload,
      auto_preload: true
    };
    
    const startPage = {
      type: jsPsych.HtmlKeyboardResponse,
      stimulus: '<p>Willkommen zum Experiment.</p><p>Drücken Sie eine beliebige Taste, um zu beginnen.</p>',
    };

    // ==== HELPER-FUNKTIONEN ====
    function getInstructions(blockName, highlight) {
      const highlightText = highlight ?
        "In diesem Block werden einige Apps auf dem Bildschirm hervorgehoben. Ihre Aufgabe bleibt dieselbe." :
        "In diesem Block gibt es keine Hervorhebungen. Ihre Aufgabe bleibt dieselbe.";

      return {
        type: jsPsych.HtmlKeyboardResponse,
        stimulus: `<div class="instructions">
          <h2>Anweisungen für ${blockName}</h2>
          <p>Ihre Aufgabe ist es, so schnell und genau wie möglich eine bestimmte "Ziel-App" auf dem Bildschirm zu finden und anzuklicken.</p>
          <p>Zu Beginn jedes Abschnitts zeigen wir Ihnen die Ziel-App, die Sie sich merken müssen.</p>
          <p>${highlightText}</p>
          <p>Nachdem Sie die Ziel-App gefunden und angeklickt haben, wird der nächste Versuch automatisch gestartet.</p>
          <p>Manchmal werden wir Sie zwischendurch fragen, welche App die aktuelle Ziel-App ist.</p>
          <p>Zuerst kommen ein paar Übungsdurchgänge.</p>
          <p>Drücken Sie eine beliebige Taste, um mit der Übung für diesen Block zu beginnen.</p>
        </div>`,
        data: {
          task: 'instructions',
          block_name: blockName
        }
      };
    }

    function getShowTarget(target, highlight) {
      return {
        type: jsPsych.HtmlKeyboardResponse,
        stimulus: `
          <div class="show-target">
            <h2>Merken Sie sich die neue Ziel-App:</h2>
            <div style="display: flex; justify-content: center; align-items: center; margin: 20px;">
              <div class="grid-item">
                <div class="app-name">${target.name}</div>
                <div class="app-symbol">${target.symbol}</div>
              </div>
            </div>
            <p>Drücken Sie eine beliebige Taste, um fortzufahren.</p>
          </div>
        `,
        data: {
          task: 'show_target',
          target_name: target.name,
          target_symbol: target.symbol,
          highlight_condition: highlight
        }
      };
    }

    function getSearchTrial(gridApps, highlight, blockLabel, getProbeType) {
      const isProbe = getProbeType() === 'probe';
      const highlightClass = highlight && isProbe ? 'highlight' : '';

      let stimulusHtml = '<div class="grid-container">';
      gridApps.forEach((app, index) => {
        stimulusHtml += `
          <div class="grid-item ${app.isTarget ? highlightClass : ''}" id="app-${index}" data-app-name="${app.name}" data-is-target="${app.isTarget}">
            <div class="app-name">${app.name}</div>
            <div class="app-symbol">${app.symbol}</div>
          </div>`;
      });
      stimulusHtml += '</div>';

      return {
        type: jsPsych.HtmlKeyboardResponse,
        stimulus: stimulusHtml,
        choices: "NO_KEYS",
        trial_duration: 5000,
        on_load: function() {
          const startTime = performance.now();
          gridApps.forEach((app, index) => {
            const el = document.getElementById(`app-${index}`);
            el.addEventListener('click', (e) => {
              const endTime = performance.now();
              const rt = endTime - startTime;
              const choice = e.currentTarget.dataset.appName;
              const correct = e.currentTarget.dataset.isTarget === 'true';
              
              jsPsych.finishTrial({
                rt: rt,
                correct: correct,
                choice: choice,
              });
            });
          });
        },
        data: {
          task: 'search',
          probe_type: isProbe ? 'probe' : 'non-probe',
          target_name: gridApps.find(app => app.isTarget).name,
          highlight_condition: highlight,
          block_label: blockLabel
        }
      };
    }
    
    function getMemoryCheckTrial(isPractice) {
        const currentTarget = jsPsych.timelineVariable('currentTarget');
        let options = jsPsych.randomization.sampleWithoutReplacement(appNames.filter(n => n !== currentTarget.name), 3);
        options.push(currentTarget.name);
        options = jsPsych.randomization.shuffle(options);

        let stimulusHtml = '<h2>Welche App ist das aktuelle Ziel?</h2><div class="memory-check-container">';
        options.forEach(name => {
            stimulusHtml += `<div class="memory-check-option" data-app-name="${name}"><div class="app-name">${name}</div></div>`;
        });
        stimulusHtml += '</div>';

        return {
            type: jsPsych.HtmlKeyboardResponse,
            stimulus: stimulusHtml,
            choices: "NO_KEYS",
            trial_duration: 5000,
            on_load: function() {
                const startTime = performance.now();
                document.querySelectorAll('.memory-check-option').forEach(el => {
                    el.addEventListener('click', (e) => {
                        const rt = performance.now() - startTime;
                        const choice = e.currentTarget.dataset.appName;
                        const correct = choice === currentTarget.name;
                        jsPsych.finishTrial({
                            rt: rt,
                            correct: correct,
                            choice: choice,
                        });
                    });
                });
            },
            data: {
                task: isPractice ? 'practice_memory_check' : 'memory_check',
                target_name: currentTarget.name
            }
        };
    }

    function getConfirmMemoryCheckTrial(isPractice) {
        const currentTarget = jsPsych.timelineVariable('currentTarget');
        const prompt = `<p>Ist <strong>${currentTarget.name}</strong> die aktuelle Ziel-App?</p>`;

        return {
            type: jsPsych.SurveyLikert,
            questions: [{
                prompt: prompt,
                labels: ["Nein", "Ja"],
                required: true
            }],
            data: {
                task: isPractice ? 'practice_confirm_check' : 'confirm_memory_check',
                target_name: currentTarget.name,
                is_correct_target_shown: true 
            },
            on_finish: function(data) {
                data.correct = data.response.Q0 === 1; // 1 = "Ja"
            }
        };
    }
    
    function makePracticeBlock(highlight) {
        const practiceTarget = { name: "TestApp", symbol: '★\uFE0E' };
        
        let practiceDistractors = jsPsych.randomization.sampleWithoutReplacement(appNames.filter(n => n !== practiceTarget.name), 14);
        let practiceGridAppNames = [...practiceDistractors, practiceTarget.name];
        let practiceGridApps = jsPsych.randomization.shuffle(practiceGridAppNames).map(name => ({
            name,
            symbol: name === practiceTarget.name ? practiceTarget.symbol : symbols[Math.floor(Math.random() * symbols.length)],
            isTarget: name === practiceTarget.name
        }));

        const search_trial = {
            type: jsPsych.HtmlKeyboardResponse,
            stimulus: () => {
                let stimulusHtml = '<div class="grid-container">';
                practiceGridApps.forEach((app, index) => {
                    stimulusHtml += `
                      <div class="grid-item" id="app-${index}" data-is-target="${app.isTarget}">
                        <div class="app-name">${app.name}</div>
                        <div class="app-symbol">${app.symbol}</div>
                      </div>`;
                });
                stimulusHtml += '</div>';
                return stimulusHtml;
            },
            choices: "NO_KEYS",
            on_load: function() {
                practiceGridApps.forEach((app, index) => {
                    const el = document.getElementById(`app-${index}`);
                    el.addEventListener('click', (e) => {
                        const correct = e.currentTarget.dataset.isTarget === 'true';
                        if (correct) {
                            e.currentTarget.classList.add('practice-feedback');
                            setTimeout(() => {
                                jsPsych.finishTrial({ correct: true });
                            }, 500);
                        }
                    });
                });
            },
            data: { task: 'practice_search' }
        };

        return [
            getShowTarget(practiceTarget, highlight),
            search_trial,
            {...fixation, trial_duration: 1000},
            {
                timeline: [getMemoryCheckTrial(true)],
                timeline_variables: [{ currentTarget: practiceTarget }]
            },
            {...fixation, trial_duration: 1000},
            {
                timeline: [getConfirmMemoryCheckTrial(true)],
                timeline_variables: [{ currentTarget: practiceTarget }]
            },
            {
                type: jsPsych.HtmlKeyboardResponse,
                stimulus: "<p>Übung beendet. Drücken Sie eine Taste, um mit dem Block zu beginnen.</p>"
            }
        ];
    }
    
    function makeBlockTrials(highlight, blockLabel, probeArr, blockOrderNumber, blockTargets, allExperimentTargets) {
        const block = [];
        let probeCounter = 0;
        
        const displayBlockName = `Block ${blockOrderNumber}`;
        block.push(getInstructions(displayBlockName, highlight));
        
        block.push(...makePracticeBlock(highlight));

        let currentTargetIdx = 0;
        block.push(getShowTarget(blockTargets[currentTargetIdx], highlight));

        const allTrialIndices = Array.from({length: trialsPerBlock}, (_, k) => k);
        const numberOfChecks = Math.floor(trialsPerBlock * 0.30);
        const memoryCheckIndices = jsPsych.randomization.sampleWithoutReplacement(allTrialIndices, numberOfChecks);

        const checkTypes = [];
        const numAppChecks = Math.floor(numberOfChecks / 2);
        const numConfirmChecks = Math.ceil(numberOfChecks / 2);

        for (let j = 0; j < numAppChecks; j++) {
          checkTypes.push('app_check');
        }
        for (let j = 0; j < numConfirmChecks; j++) {
          checkTypes.push('confirm_check');
        }
        
        const shuffledCheckTypes = jsPsych.randomization.shuffle(checkTypes);

        for (let i = 0; i < trialsPerBlock; i++) {
          
          if (i > 0 && i % TRIALS_PER_TARGET === 0) {
            currentTargetIdx = Math.floor(i / TRIALS_PER_TARGET);
            if(blockTargets[currentTargetIdx]){ // Sicherheitscheck, falls Trials nicht genau aufgehen
                block.push(getShowTarget(blockTargets[currentTargetIdx], highlight));
            }
          }

          let currentTarget = blockTargets[currentTargetIdx];

          const forbiddenNames = allExperimentTargets.map(t => t.name);
          let availableDistractors = appNames.filter(name => !forbiddenNames.includes(name));
          let gridAppNames = jsPsych.randomization.sampleWithoutReplacement(availableDistractors, 14);
          gridAppNames.push(currentTarget.name);
          
          let gridApps = jsPsych.randomization.shuffle(gridAppNames).map(name => ({
            name,
            symbol: name === currentTarget.name ? currentTarget.symbol : symbols[Math.floor(Math.random() * symbols.length)],
            isTarget: name === currentTarget.name
          }));

          block.push(getSearchTrial(
            gridApps,
            highlight,
            blockLabel,
            () => probeArr[probeCounter++]
          ));

          if (memoryCheckIndices.includes(i)) {
            const checkType = shuffledCheckTypes.pop(); 

            if (checkType === 'app_check') {
                block.push({
                    timeline: [getMemoryCheckTrial(false)],
                    timeline_variables: [{ currentTarget: currentTarget }]
                });
            } else { // 'confirm_check'
                block.push({
                    timeline: [getConfirmMemoryCheckTrial(false)],
                    timeline_variables: [{ currentTarget: currentTarget }]
                });
            }
          }
          
          block.push(fixation);
        }
        return block;
    }


    // === Timeline ===
    const block_definitions = [
      { highlight: false, label: "Test-Block", probes: probeArrBlock1 },
      { highlight: true, label: "Baseline-Block", probes: probeArrBlock2 }
    ];

    const randomized_blocks = jsPsych.randomization.shuffle(block_definitions);

    // --- ANGEPASSTE LOGIK: ZIELE DYNAMISCH BERECHNEN ---
    const numTargetsPerBlock = Math.ceil(trialsPerBlock / TRIALS_PER_TARGET);
    const totalNumberOfTargets = numTargetsPerBlock * 2;

    if (appNames.length < totalNumberOfTargets + 14) {
      alert("FEHLER: Die 'appNames'-Liste ist zu kurz für die Anzahl der Trials und Ziele!");
    }
    
    const allExperimentTargetNames = jsPsych.randomization.sampleWithoutReplacement(appNames, totalNumberOfTargets);
    const allExperimentTargets = allExperimentTargetNames.map(name => ({
        name: name,
        symbol: symbols[Math.floor(Math.random() * symbols.length)]
    }));

    const targetsForBlock1 = allExperimentTargets.slice(0, numTargetsPerBlock);
    const targetsForBlock2 = allExperimentTargets.slice(numTargetsPerBlock);
    // --- ENDE DER ANGEPASSTEN LOGIK ---

    const firstBlock = makeBlockTrials(
      randomized_blocks[0].highlight,
      randomized_blocks[0].label,
      randomized_blocks[0].probes,
      1,
      targetsForBlock1, 
      allExperimentTargets
    );

    const secondBlock = makeBlockTrials(
      randomized_blocks[1].highlight,
      randomized_blocks[1].label,
      randomized_blocks[1].probes,
      2,
      targetsForBlock2,
      allExperimentTargets
    );
    
    const timeline = [preload, startPage, ...firstBlock, ...secondBlock];

    jsPsych.run(timeline);

  </script>
</body>
</html>