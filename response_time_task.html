<!DOCTYPE html>
<html>
<head>
    <title>SAP App Task</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.1"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" />
    <style>
    /* Diese Regel wird nur auf Trials angewendet, denen wir die Klasse'vertically-centered-content' 
    im JavaScript-Code geben. */
      .jspsych-trial.vertically-centered-content .jspsych-display-element {
          display: flex;
          flex-direction: column;
          justify-content: center; /* Zentriert den Inhalt vertikal */
          height: 100%;            /* F√ºllt den gesamten verf√ºgbaren Platz aus */
      }

      /* Diese Regel verhindert, dass unser App-Grid von der Zentrierung betroffen ist,
        und behebt das Problem der Rechtsverschiebung. */
      .jspsych-display-element {
          width: 100%;
      }

      /* Passt die Breite der Textbl√∂cke NUR auf den zentrierten Seiten an */
      .jspsych-trial.vertically-centered-content .jspsych-display-element > div {
        max-width: 900px; /* Beh√§lt die maximale Breite f√ºr Lesbarkeit bei */
        width: 100%;
        text-align: left; /* Stellt sicher, dass der Text linksb√ºndig bleibt */
      }
      
      html, body {
        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;
        overflow: hidden !important;
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background: #f5f6f7;
      }
      .sap-header {
        position: fixed;
        top: 0; left: 0; width: 100vw; z-index: 0;
        background: #fff;
        height: 82px;
        box-shadow: 0 2px 3px 0 rgba(0,0,0,0.05), 0 1px 0px 0 #e2e5e7;
        border-bottom: 1.5px solid #e2e5e7;
        display: flex;
        align-items: center;
        padding: 0 30px;
      }
      .sap-logo {
        height: 35px;
        width: 68px;
        margin-right: 24px;
      }
      .header-menu {
        display: flex;
        align-items: center;
        gap: 18px;
      }
      .menu-item {
        color: #222;
        font-size: 17px;
        font-weight: bold;
        margin-right: 18px;
        cursor: pointer;
        padding: 7px 10px;
        border-radius: 6px;
      }
      .menu-item.active {
        color: #186FDB;
        border-bottom: 2px solid #186FDB;
      }
      .header-right {
        margin-left: auto;
        display: flex;
        gap: 18px;
        align-items: center;
      }
      .header-ico {
        font-size: 20px;
        color: #444;
        background: #f8f8f8;
        border-radius: 50%;
        padding: 5px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 2px;
      }
      .header-avatar {
        width: 35px;
        height: 35px;
        background: #dbeafe;
        color: #2981ea;
        border-radius: 999px;
        display: flex;
        align-items: center; justify-content: center;
        font-size: 18px; font-weight: bold;
        margin-left: 10px;
      }
      .sap-overview {
        position: fixed;
        top: 90px; left: 2.3vw; z-index: 0;
        font-size: 2.0vw; font-weight: bold; color: #262f38;
        text-shadow: 0 1px 0 #fff;
        letter-spacing: 0;
        margin-bottom: 16px;
      }
      .sap-grey-bg {
        position: fixed;
        top: 125px;
        left: 0;
        width: 100vw;
        height: calc(100vh - 125px);
        background: linear-gradient(180deg,#F5F7F8 80%,#EDF0F1 100%);
        z-index: 0;
      }
      #jspsych-container,
      .app-container {
        width: 100vw;
        height: calc(100vh - 125px);
        overflow: hidden;
        position: relative;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

    .app-container {
      width: 100vw;
      height: calc(100vh - 125px);
      overflow: hidden;
      position: relative;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .app-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(4, 1fr);
      width: 100%;
      height: 100%;
      gap: 2.5vw;
      padding: 2.5vw;
      box-sizing: border-box;
      justify-items: center;
      align-items: center;
    }

    .app-box {
      aspect-ratio: 1 / 1;
      width: 100%;
      max-width: 9vw;
      max-height: 100%;
      background-color: white;
      border: 2px solid #ccc;
      border-radius: 1vw;
      box-shadow: 0.2vw 0.2vw 0.5vw rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      user-select: none;
      text-align: center;
      font-size: 1.6vw;
      transition: border 0.2s;
      z-index: 10;
      min-width: 0;
      min-height: 0;
    }

    .empty-app {
      background: #e4e8ec !important;
      border: 2px solid #bbb;
      cursor: pointer;
      transition: background 0.2s;
    }
    .app-box.empty-app:hover {
      background: #cdd8df !important;
    }
      .symbol {
        font-size: 2vw;
        color: #555;
      }
      .fixation-screen {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: white;
        font-size: 5vw;
      }
      .confirm-box {
        position: absolute;
        background-color: #fff;
        color: #1976d2;
        padding: 0.2vw 0.7vw;
        border-radius: 8px;
        font-size: 1vw;
        cursor: pointer;
        z-index: 20;
        border: 2px solid  #1976d2;
        font-weight: 500;
        box-shadow: none;
        font-family: inherit;
        width: 4vw;
        height: 2.2vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .highlight-target {
        border: 4px solid #888 !important;
        box-shadow: 0 0 12px #bbb !important;
      }
      @media (max-width: 704px) {
        .sap-overview { font-size: 26px; }
        .app-box { font-size: 18px; }
        .symbol { font-size: 23px; }
        .confirm-box { font-size: 13px; width: 60px; height: 40px; }
        .app-grid { gap: 2vw; }
      }
    </style>
</head>
<body>
<div id="sap-bg">
  <div class="sap-header">
    <svg class="sap-logo" width="68" height="35" viewBox="0 0 68 35" xmlns="http://www.w3.org/2000/svg">
      <rect width="68" height="35" fill="#008FD3" />
    </svg>
    <span style="font-size:23px; margin-right:14px; cursor:pointer;">‚ò∞</span>
    <div class="header-menu">
      <span class="menu-item">Lunivox</span>
      <span class="menu-item">Trenola</span>
      <span class="menu-item active">Seraquix <span style="font-size:13px;">‚ñº</span></span>
    </div>
    <div class="header-right">
      <span class="header-ico">üîç</span>
      <span class="header-ico">üìç</span>
      <span class="header-ico">üéß</span>
      <span class="header-ico">‚ùì</span>
      <span class="header-ico">üîî</span>
      <span class="header-avatar">VM</span>
    </div>
  </div>
  <div class="sap-overview">Equao</div>
  <div class="sap-grey-bg"></div>
</div>
<div id="jspsych-container" style="position:absolute;top:125px;left:0;width:100vw;height:calc(100vh - 125px);z-index:10;"></div>
<script>
  // Erg√§nzungen gegen Scrollen/Window-Resizing
  window.addEventListener('scroll', function() { window.scrollTo(0,0); });
  document.body.style.overflow = 'hidden';
  document.documentElement.style.overflow = 'hidden';
</script>
<script>
  // SAP-Hintergrund An/Aus helper
  function showSAPBackground(show = true) {
    const sapBg = document.getElementById('sap-bg');
    const jspsychContainer = document.getElementById('jspsych-container');

    if (show) { 
      // === STIL F√úR GRID-TRIALS (MIT SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = '';
      document.body.style.background = "#f5f6f7";
      if (jspsychContainer) {
        jspsychContainer.style.top = '125px';
        jspsychContainer.style.height = 'calc(100vh - 125px)';
      }
    } else { 
      // === STIL F√úR TEXT-TRIALS (OHNE SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = 'none';
      document.body.style.background = "white";
      if (jspsychContainer) {
        // Wir setzen den Container auf volle Bildschirmh√∂he
        jspsychContainer.style.top = '0px';
        jspsychContainer.style.height = '100vh';
      }
    }
  }

  // ==== KONSTANTEN ====
  const appNames = [
      "Limo7", "Loru7", "HivoN", "HoruN", 
      "PikaX", "PoliX", "Pansi2", "Pexi2", 
      "MenoL", "MuniL", "Fexa5", "Fumi5",
      "Venni9", "Vabo9", "Vuma3", "Vezu3",
      "SuniX", "SokuX", "Samr7", "Seda7",
      "RafiQ", "RibuQ", "RapoM", "RenuM",
      "Keso2", "Kipu2", "KanoL", "KuraL", 
      "KariQ", "KesoQ"
    ];
  const symbols = [
    '‚ñ≤\uFE0E',  '‚ñ†\uFE0E',  '‚óè\uFE0E',  '‚óÜ\uFE0E',  '‚òÖ\uFE0E',  '‚úö\uFE0E', '‚òÄ\uFE0E', '‚òÅ\uFE0E', '‚ôû\uFE0E'
  ];

  // ==== JSPSYCH INIT ====
  const jsPsych = initJsPsych({
    display_element: 'jspsych-container',
    on_finish: function() {
        // Daten als CSV herunterladen
        jsPsych.data.get().localSave('csv', 'sap_app_task_data.csv', {
            exclude_columns: ['timeout', 'failed_images', 'failed_video', 'failed_audio']
        });

        // Optional: Eine "Danke"-Nachricht anzeigen, damit der Teilnehmer wei√ü, dass das Experiment beendet ist.
        document.getElementById('jspsych-container').innerHTML = `
            <div style="max-width: 900px; margin: 0 auto; text-align: center; padding-top: 100px;">
                <h2>Vielen Dank f√ºr Ihre Teilnahme!</h2>
                <p>Ihre Daten wurden automatisch gespeichert.</p>
                <p>Sie k√∂nnen das Fenstern nun schlie√üen.</p>
            </div>
        `;
        // Stellen Sie sicher, dass der SAP-Hintergrund f√ºr die Danke-Nachricht ausgeblendet ist
        showSAPBackground(false);
    }
  });

  // ==== Bl√∂cke mit 50/50 pro Typ ===
  const totalTrials = 16; 
  const trialsPerBlock = totalTrials / 2; 

  function generateProbeArray(n) {
    let arr = [];
    for (let i = 0; i < n / 2; i++) arr.push('on-probe');
    for (let i = 0; i < n / 2; i++) arr.push('off-probe');
    return jsPsych.randomization.shuffle(arr);
  }
  let probeArrBlock1 = generateProbeArray(trialsPerBlock);
  let probeArrBlock2 = generateProbeArray(trialsPerBlock);

  const preload = {
    type: jsPsychPreload,
    images: [],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true)
  };

  const startPage = {
    type: jsPsychHtmlButtonResponse,
    stimulus: `
      <div style="max-width: 900px; margin: 0 auto; text-align: left;">
        <h2>Willkommen zum Experiment</h2>
        <p>Das Experiment wird ungef√§hr 30 Minuten dauern. Bitte stellen Sie sicher, dass sie w√§hrend dieser Zeit nicht gest√∂rt werden.</p>
        <p>Es wird empfohlen, das Experiment an einem Laptop / Computer oder an einem Tablet mit angeschlossener Tastatur durchzuf√ºhren, weil Sie die Leertaste brauchen.</p>
        <p>In diesem Experiment sehen Sie Raster mit App-Kacheln. Zu Beginn jedes Blocks wird Ihnen eine Ziel-App gezeigt. 
        Ihre Aufgabe ist es, die Ziel-App im nachfolgenden Raster so schnell wie m√∂glich zu entdecken und die Leertaste zu dr√ºcken. 
        Anschlie√üend erscheint ein Feld ‚ÄûBest√§tigen‚Äú, bei dem Sie ebenfalls so schnell wie m√∂glich die Leertaste dr√ºcken sollen.</p>
        <p>Im Anschluss an einen Durchgang k√∂nnen kurze Ged√§chtnistests folgen, in denen Ihre Aufmerksamkeit √ºberpr√ºft wird.</p>
        <p>Wenn Sie bereit sind, klicken Sie auf ‚ÄûWeiter‚Äú, um zu beginnen.</p>
      </div>
    `,
    choices: ['Weiter'],
    css_classes: ['vertically-centered-content'],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true),
    // Hinzugef√ºgte block_type-Information
    data: { trial_stage: 'instruction', block_type: 'Einleitung' }
};

  // NEUE DEFINITION DES FIXATIONS-TRIALS, UM DAS STARTPROBLEM ZU BEHEBEN
  function getFixationTrial(blockType = 'unknown') {
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<div style="width:100vw;height:100vh;background:white"></div>',
      choices: [],
      trial_duration: 1000,
      response_ends_trial: false, // <--- DIES IST DIE ENTSCHEIDENDE ZEILE F√úR DIE BEHEBUNG DES STARTPROBLEMS!
      on_load: () => showSAPBackground(true),
      data: { trial_stage: 'fixation', block_type: blockType }
    };
  }

  // Parameter blockType hinzugef√ºgt
  function getShowTarget(targetApp, highlight, blockType) {
      return {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => `
          <div style="max-width:900px; margin:0 auto; text-align:center;">
            <p><b>Dies ist die Ziel-App f√ºr die n√§chsten Trials.</b><br>
            Merken Sie sich Name und Symbol!</p>
            <p> Es gibt w√§hrend der n√§chsten Trials kein Feedback f√ºr die richtige Aushwahl der Ziel-App oder "Best√§tigen" Button Position, ob Ihre Wahl richtig 
              oder falsch war wird aber dennoch vermerkt.</p>
            <div style="display:flex; justify-content:center;">
              <div class="app-box${highlight ? ' highlight-target' : ''}" style="width:9vw; display:inline-flex;">
                ${targetApp.name}<div class="symbol">${targetApp.symbol}</div>
              </div>
            </div>
            <p style="margin-top: 30px;"><b>Dr√ºcken Sie die Leertaste, um fortzufahren.</b></p>
          </div>`,
        choices: [' '],
        css_classes: ['vertically-centered-content'],
        on_load: () => showSAPBackground(false),
        on_finish: () => showSAPBackground(true),
        // Hinzugef√ºgte block_type-Information
        data: { trial_stage: 'show_target', target_app_name: targetApp.name, target_app_symbol: targetApp.symbol, block_type: blockType }
      };
    }

    // Parameter blockType hinzugef√ºgt
    function getInstructions(blockName, highlight, blockType) {
    const step2_instruction = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe immer <b>mit einem dunkelgrauen Rahmen markiert</b>. Dr√ºcken Sie so schnell wie m√∂glich die <b>Leertaste</b>.`
      : `Finden Sie die Ziel-App im Raster und dr√ºcken Sie so schnell wie m√∂glich die <b>Leertaste</b>.`;

    const stimulus_html = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">${blockName}</h2>
        <p>In diesem Block sehen Sie in mehreren Durchg√§ngen ein Raster mit Apps. Ihre Aufgabe ist es, in jedem Durchgang die folgenden Schritte so schnell und genau wie m√∂glich auszuf√ºhren:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Pr√§gen Sie sich die <b>Ziel-App</b> ein, die Ihnen zu Beginn und bei einem Wechsel angezeigt wird.</li>
          <li style="margin-bottom: 15px;">${step2_instruction}</li>
          <li style="margin-bottom: 15px;">Ein Feld mit "<b>Best√§tigen</b>" erscheint an einer zuf√§lligen Stelle. Reagieren Sie darauf ebenfalls so schnell wie m√∂glich mit der <b>Leertaste</b>.</li>
          <li style="margin-bottom: 15px;">Nach einigen Durchg√§ngen folgt ein kurzer Ged√§chtnistest. Sie werden dann gebeten, <b>entweder</b> die Position der Ziel-App <b>oder</b> die Position des ‚ÄûBest√§tigen‚Äú-Buttons per Mausklick anzugeben. Es treten niemals beide Tests direkt nacheinander auf.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">Wenn Sie bereit sind, klicken Sie auf "Weiter".</p>
      </div>
    `;

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: stimulus_html,
      choices: ['Weiter'],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      // Hinzugef√ºgte block_type-Information
      data: { trial_stage: 'block_instruction', block_name_display: blockName, block_type: blockType }
    };
  }

  function renderLayoutRandomGrid(apps, highlightTarget) {
    let positions = [];
    for (let row = 1; row <= 4; row++) {
      for (let col = 1; col <= 6; col++) {
        positions.push({ row, col });
      }
    }
    for (let i = positions.length - 1; i > 0; i--) {
      let j = Math.floor(Math.random() * (i + 1));
      [positions[i], positions[j]] = [positions[j], positions[i]];
    }
    let usedPositions = positions.slice(0, apps.length);

    let html = `<div class="app-grid">`;
    usedPositions.forEach((pos, idx) => {
      let app = apps[idx];
      let targetClass = (highlightTarget && app.isTarget) ? " highlight-target" : "";
      html += `<div id="app-${idx}" class="app-box${targetClass}" 
                style="grid-row: ${pos.row}; grid-column: ${pos.col};">
                ${app.name}<div class="symbol">${app.symbol}</div>
              </div>`;
    });
    html += "</div>";
    return html;
  }

  const layoutRenderers = [renderLayoutRandomGrid];
  const layoutNames = ["RandomGrid4x6"];

  // Parameter blockType hinzugef√ºgt
  function getSearchTrial(apps, highlightTarget, blockLabel, getProbeTypeFunction, blockType) {
    const randomIndex = Math.floor(Math.random() * layoutRenderers.length);
    const renderer = layoutRenderers[randomIndex];
    const layoutName = layoutNames[randomIndex];
    
    // WICHTIG: getProbeTypeFunction sofort ausf√ºhren, um den Probe-Typ f√ºr DIESEN Trial zu erhalten
    const currentTrialProbeType = getProbeTypeFunction(); 

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        let html = `<div class="app-container">` + renderer(apps, highlightTarget) + `</div>
        <div style="margin-top:2em; font-size:1.2vw; color:#333;"><b>Dr√ºcken Sie die Leertaste sobald Sie die Ziel-App entdeckt haben!</b></div>`;
        return html;
      },
      choices: 'NO_KEYS',
      // Hinzugef√ºgte block_type-Information
      data: { 
        trial_stage: 'search_task', 
        block_type: blockType, 
        original_block_label: blockLabel,
        is_target_highlighted: highlightTarget, // Zus√§tzliche n√ºtzliche Info
        layout: layoutName,
        probe_type: currentTrialProbeType // <--- HIER wird der probe_type direkt zum Trial-Data hinzugef√ºgt
      }, 
      on_load: (trial) => {
        showSAPBackground(true);
        // jsPsych.data.addProperties({ layout: layoutName }); // Wird jetzt direkt im data-Objekt des Trials gespeichert.

        window.currentGridApps = apps.map(x => ({...x}));
        window.gridPositions = [];
        document.querySelectorAll('.app-box').forEach((box,i) => {
          window.gridPositions.push({
            i: i,
            style: box.getAttribute('style')
          });
        });
        window.memoryCheckTargetIdx = apps.findIndex(a => a.isTarget);

        window.appScreenStart = performance.now();
        window.appRects = apps.map((a, i) => {
          const el = document.getElementById('app-' + i).getBoundingClientRect();
          return {
            name: a.name,
            x: el.left,
            y: el.top,
            width: el.width,
            height: el.height,
            isTarget: a.isTarget
          }
        });

        let finished = false;
        const handler = (e) => {
          if (e.code === 'Space' || e.key === ' ' || e.keyCode === 32) e.preventDefault();
          if (!finished && (e.code === 'Space' || e.key === ' ' || e.keyCode === 32)) {
            finished = true;
            const rt_select = performance.now() - window.appScreenStart;
            // jsPsych.data.addProperties({ rt_select: rt_select }); // NICHT MEHR GLOBAL SPEICHERN
            
            const targetRectIdx = apps.findIndex(a => a.isTarget);
            let appRect = document.getElementById('app-' + targetRectIdx).getBoundingClientRect(); 
            window.appPosition = { x: appRect.left, y: appRect.top, width: appRect.width, height: appRect.height };

            const pause = jsPsych.randomization.sampleWithoutReplacement([200, 300, 400, 500], 1)[0];
            // showConfirmButton gibt jetzt Daten zur√ºck, die an jsPsych.finishTrial √ºbergeben werden
            setTimeout(() => showConfirmButton((confirmData) => { 
              const confirmPosition = window.confirmPosition;
              jsPsych.finishTrial({ // Alle Daten f√ºr diesen Trial hier zusammenf√ºhren
                rt_select: rt_select, 
                app1_position_x: window.appPosition.x,
                app1_position_y: window.appPosition.y,
                confirm_position_x: confirmPosition.x,
                confirm_position_y: confirmPosition.y,
                ...confirmData // Daten von showConfirmButton hier einf√ºgen
              });
            }, false, currentTrialProbeType), pause); // Hier den bereits bestimmten probe_type √ºbergeben

            document.removeEventListener('keydown', handler, true);
          }
        };
        document.addEventListener('keydown', handler, true);
      },
      on_unload: () => {
        document.onkeydown = null;
      }
    };
  }

  // Parameter blockType hinzugef√ºgt
  function getMemoryCheckTrial(isPracticeTrial = false, blockType = 'unknown') {
    return {
      type: jsPsychHtmlButtonResponse,
      choices: [],
      response_ends_trial: false,
      // Hinzugef√ºgte block_type-Information
      data: { 
        trial_stage: 'memory_check_app_pos', 
        block_type: blockType, 
        is_practice_trial: isPracticeTrial 
      }, 
      stimulus: () => {
        const containerStyle = window.overrideContainerStyle || '';
        const gridStyle = window.overrideGridStyle || window.gridContainerStyle || '';
        
        let html = `<div class="app-container" style="${containerStyle}"><div class="app-grid" style="${gridStyle}">`;

        if (window.overrideGridStyle) {
            window.currentGridApps.forEach((app, idx) => {
                html += `<div class="app-box empty-app" data-idx="${idx}" style="cursor:pointer;"></div>`;
            });
        } else {
            window.currentGridApps.forEach((app, idx) => {
              html += `<div class="app-box empty-app" 
                            data-idx="${idx}"
                            style="${window.gridPositions[idx]?.style || ''}; cursor:pointer;">
                      </div>`;
            });
        }
        html += `</div></div>`;
        return html;
      },
      on_load: () => {
        const instructionEl = document.createElement('div');
        instructionEl.style.position = 'absolute';
        instructionEl.style.top = '135px';
        instructionEl.style.left = '20px';
        instructionEl.style.zIndex = '1000';
        instructionEl.style.fontSize = '1.2vw';
        instructionEl.style.color = '#333';
        instructionEl.innerHTML = '<b>Bitte klicken Sie auf das Feld, auf dem die Ziel-App gerade war!</b>';
        document.body.appendChild(instructionEl);
        window.tempInstructionText = instructionEl;

        const allBoxes = document.querySelectorAll('.app-box.empty-app');
        allBoxes.forEach(div=>{
          div.style.background = "#e4e8ec";
          div.innerHTML = '';
        });
        
        allBoxes.forEach(box => {
          box.addEventListener('click', (e) => {
            allBoxes.forEach(b => b.style.pointerEvents = 'none');

            const clickedIdx = parseInt(box.getAttribute('data-idx'), 10);
            const correct = (clickedIdx === window.memoryCheckTargetIdx);
            
            box.style.background = correct ? "#b7e7b4" : "#ffd1b9";

            if (isPracticeTrial) {
              if (correct) {
                box.innerHTML = '<span style="color: #107E3e; font-weight: bold; font-size: 1.5vw;">Richtig!</span>';
              } else {
                box.innerHTML = '<span style="color: #A91D1D; font-weight: bold; font-size: 1.5vw;">Falsch!</span>';
              }
            }
            
            // HIER DIE √ÑNDERUNG: Daten direkt an finishTrial √ºbergeben, nicht global addProperties
            const dataToPass = {
                memorycheck_clicked_idx: clickedIdx,
                memorycheck_correct: correct,
                memorycheck_target_idx: window.memoryCheckTargetIdx
            };
            
            const trial_duration = isPracticeTrial ? 1500 : 500;
            setTimeout(() => jsPsych.finishTrial(dataToPass), trial_duration); // Daten hier √ºbergeben
          }, { once: true });
        });
      },
      on_finish: () => {
        if (window.tempInstructionText) {
            window.tempInstructionText.remove();
            window.tempInstructionText = null;
        }
        window.gridContainerStyle = '';
        window.overrideGridStyle = '';
        window.overrideContainerStyle = '';
      }
    };
  }

  // Parameter blockType hinzugef√ºgt
  function getConfirmMemoryCheckTrial(isPracticeTrial = false, blockType = 'unknown') {
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: '', 
      choices: [],
      response_ends_trial: false,
      // Hinzugef√ºgte block_type-Information
      data: { 
        trial_stage: 'memory_check_confirm_pos', 
        block_type: blockType, 
        is_practice_trial: isPracticeTrial 
      }, 
      on_load: () => {
        const displayElement = document.querySelector('#jspsych-container .jspsych-display-element');
        if(displayElement) displayElement.innerHTML = '';

        const correct_pos = window.confirmPosition;
        if (!correct_pos) {
            jsPsych.finishTrial();
            return;
        }

        const elementsToCleanUp = [];

        const instructionEl = document.createElement('div');
        instructionEl.style.position = 'absolute';
        instructionEl.style.top = '135px';
        instructionEl.style.left = '20px';
        instructionEl.style.zIndex = '1000';
        instructionEl.style.fontSize = '1.2vw';
        instructionEl.style.color = '#333';
        instructionEl.innerHTML = "<b>Bitte klicken Sie auf die Position, an der der 'Best√§tigen' Button gerade war!</b>";
        document.body.appendChild(instructionEl);
        elementsToCleanUp.push(instructionEl);

        const buttonW = 0.04 * window.innerWidth > 60 ? 0.04 * window.innerWidth : 60;
        const buttonH = 0.022 * window.innerWidth > 40 ? 0.022 * window.innerWidth : 40;
        const min_dist = 200;

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function generateFoilPosition(existing_positions) {
            let foil_pos;
            let tries = 0;
            const maxTries = 100;
            
            // Wir verwenden hier die gleiche Logik wie in showConfirmButton f√ºr konsistente Grenzen
            const minimumTopInPixels = 140;
            const topBoundary = Math.max(minimumTopInPixels, window.innerHeight * 0.10);
            const bottomBoundary = window.innerHeight - (window.innerHeight * 0.05);

            while (tries < maxTries) {
                tries++;
                foil_pos = {
                    x: Math.random() * (window.innerWidth - buttonW - 40) + 20,
                    // Die Y-Position wird nun innerhalb der sicheren Grenzen berechnet
                    y: topBoundary + Math.random() * (bottomBoundary - topBoundary - buttonH)
                };

                let tooClose = false;
                for (const pos of existing_positions) {
                    if (distance(foil_pos, pos) < min_dist) {
                        tooClose = true;
                        break;
                    }
                }
                if (!tooClose) return foil_pos;
            }
            // Fallback, falls keine gute Position gefunden wird
            return { x: Math.random() * (window.innerWidth - buttonW), y: topBoundary + Math.random() * (bottomBoundary - topBoundary - buttonH) };
        }

        // === NEUER CODE BEGINNT HIER F√úR DIE VERZ√ñGERUNG ===
        // Erstellen Sie die Buttons erst nach einer Verz√∂gerung
        setTimeout(() => {
          const positions_to_check = [correct_pos];
          const foil1 = generateFoilPosition(positions_to_check);
          positions_to_check.push(foil1);
          const foil2 = generateFoilPosition(positions_to_check);

          const all_buttons_data = [ { pos: correct_pos, correct: true }, { pos: foil1, correct: false }, { pos: foil2, correct: false } ];
          const shuffled_buttons = jsPsych.randomization.shuffle(all_buttons_data);

          shuffled_buttons.forEach(button_data => {
              const btn = document.createElement('div');
              btn.className = 'confirm-box';
              btn.textContent = 'Best√§tigen';
              btn.style.position = 'absolute';
              btn.style.left = `${button_data.pos.x}px`;
              btn.style.top = `${button_data.pos.y}px`;

              btn.addEventListener('click', () => {
                  elementsToCleanUp.forEach(b => b.style.pointerEvents = 'none');

                  const correct = button_data.correct;
                  // HIER DIE √ÑNDERUNG: Daten direkt an finishTrial √ºbergeben, nicht global addProperties
                  const dataToPass = {
                      confirm_memorycheck_correct: correct,
                      confirm_memorycheck_clicked_x: button_data.pos.x,
                      confirm_memorycheck_clicked_y: button_data.pos.y,
                      confirm_memorycheck_target_x: correct_pos.x,
                      confirm_memorycheck_target_y: correct_pos.y,
                  };

                  if (isPracticeTrial) {
                      if (correct) {
                          btn.style.backgroundColor = '#b7e7b4'; btn.style.borderColor = '#107E3e'; btn.style.color = '#107E3e'; btn.innerHTML = '<span style="font-weight: bold;">Richtig!</span>';
                      } else {
                          btn.style.backgroundColor = '#ffd1b9'; btn.style.borderColor = '#A91D1D'; btn.style.color = '#A91D1D'; btn.innerHTML = '<span style="font-weight: bold;">Falsch!</span>';
                      }
                  } else {
                      btn.style.backgroundColor = '#dcdcdc';
                      btn.style.borderColor = '#aaaaaa';
                  }

                  const trial_duration = isPracticeTrial ? 1500 : 500;
                  setTimeout(() => jsPsych.finishTrial(dataToPass), trial_duration); // Daten hier √ºbergeben

              }, { once: true });

              document.body.appendChild(btn);
              elementsToCleanUp.push(btn);
          });
          window.tempElements = elementsToCleanUp; // Sicherstellen, dass dies immer gesetzt wird
        }, 300); // 300 ms Verz√∂gerung
        // === NEUER CODE ENDET HIER F√úR DIE VERZ√ñGERUNG ===
      },
      on_finish: () => {
        if (window.tempElements) {
            window.tempElements.forEach(el => el.remove());
            window.tempElements = null;
        }
      }
    };
  }


  // ==== PRACTICE TRIAL ====
  const totalPracticeTrials = 3; // DEINE ORIGINAL KONSTANTE

  // Parameter blockType hinzugef√ºgt
  function createSinglePracticeTrial(highlight, trialNum, totalTrials, blockType) {
    // √úbungstrials sind von der Logik der ausgeschlossenen Apps ausgenommen,
    // sie ziehen ihre Distraktoren aus der vollst√§ndigen appNames Liste.
    const distractors = jsPsych.randomization.sampleWithoutReplacement(
      appNames, 4
    );
    const targetIdx = Math.floor(Math.random() * 4);
    let practiceApps = distractors.map((name, idx) => ({
      name: name,
      symbol: symbols[Math.floor(Math.random() * symbols.length)],
      isTarget: false
    }));
    practiceApps[targetIdx].isTarget = true;
    const practiceTarget = practiceApps[targetIdx];

    const showPracticeTarget = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="max-width:900px; margin:0 auto; text-align:center;">
          <p><b>√úbungstrial ${trialNum} von ${totalTrials}</b></p>
          <p>Das ist Ihre Ziel-App f√ºr diesen √úbungstrial.</p>
          <div style="display:flex; justify-content:center;">
            <div class="app-box${highlight ? ' highlight-target' : ''}" style="width:9vw; display:inline-flex;">
              ${practiceTarget.name}<div class="symbol">${practiceTarget.symbol}</div>
            </div>
          </div>
          <p>Merken Sie sich diese Ziel-App.<br>Im n√§chsten Bildschirm:</p>
          <p><b>Dr√ºcken Sie die Leertaste sobald Sie die Ziel-App sehen und dann noch einmal f√ºr <b>Best√§tigen</b></b>!</p>
          <p><b>In den √úbungstrials werden beide Arten des Ged√§chtnistests ge√ºbt, w√§hrend der tats√§chlichen Trials gibt es entweder gar keinen Test oder nur einen von beiden.</b></p>
          <p style="margin-top: 30px;"><b>Dr√ºcken Sie die Leertaste, um den √úbungstrial zu starten.</b></p>
        </div>`,
      choices: [' '],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      // Hinzugef√ºgte block_type-Information
      data: { trial_stage: 'show_target', block_type: blockType, target_app_name: practiceTarget.name, target_app_symbol: practiceTarget.symbol }
    };
    
    const practiceSearchTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        const shuffled = jsPsych.randomization.shuffle(practiceApps);
        window.currentGridApps = shuffled; 
        window.memoryCheckTargetIdx = shuffled.findIndex(a => a.isTarget);

        const containerStyle = 'display: flex; justify-content: center; align-items: center;';
        const gridStyle = 'grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr); width: 25vw; height: 25vw; gap: 2vw;';

        window.overrideContainerStyle = containerStyle;
        window.overrideGridStyle = gridStyle;

        let html = `<div class="app-container" style="${containerStyle}">`;
        html += `<div class="app-grid" style="${gridStyle}">`;

        shuffled.forEach((app, idx) => {
          let targetClass = (highlight && app.isTarget) ? " highlight-target" : "";
          html += `<div id="app-${idx}" class="app-box${targetClass}" data-idx="${idx}">
                    ${app.name}<div class="symbol">${app.symbol}</div>
                  </div>`;
        });
        html += '</div></div>'; 
        html += `<div style="margin-top:2em; font-size:1.2vw; color:#333;"><b>Dr√ºcken Sie die Leertaste sobald Sie die Ziel-App entdeckt haben!</b></div>`;
        return html;
      },
      choices: 'NO_KEYS',
      // Hinzugef√ºgte block_type-Information
      data: { trial_stage: 'search_task', block_type: blockType, original_block_label: `√úbungstrial ${trialNum}` }, 
      on_load: () => {
        showSAPBackground(true);

        window.appRects = [];
        document.querySelectorAll('.app-box').forEach((box, i) => {
          const el = box.getBoundingClientRect();
          window.appRects.push({
            name: window.currentGridApps[i].name,
            x: el.left,
            y: el.top,
            width: el.width,
            height: el.height,
            isTarget: window.currentGridApps[i].isTarget
          });
        });

        window.appScreenStart = performance.now();

        let finished = false;
        const handler = (e) => {
          if (e.code === 'Space' || e.key === ' ' || e.keyCode === 32) e.preventDefault();
          if (!finished && (e.code === 'Space' || e.key === ' ' || e.keyCode === 32)) {
            finished = true;
            const targetElement = document.querySelector(`.app-box[data-idx="${window.memoryCheckTargetIdx}"]`);
            if (targetElement) {
                let appRect = targetElement.getBoundingClientRect();
                window.appPosition = { x: appRect.left, y: appRect.top, width: appRect.width, height: appRect.height };
            }
            // F√ºr √úbungstrials: showConfirmButton gibt jetzt Daten zur√ºck
            showConfirmButton((confirmData) => jsPsych.finishTrial(confirmData), true); 
            document.removeEventListener('keydown', handler, true);
          }
        };
        document.addEventListener('keydown', handler, true);
      }
    };

    // Die Memory-Check Trials erhalten jetzt den blockType '√úbung'
    return [showPracticeTarget, practiceSearchTrial, getMemoryCheckTrial(true, blockType), getConfirmMemoryCheckTrial(true, blockType)];
  }

  function makePracticeBlock(highlight) {
    // totalPracticeTrials ist jetzt eine Konstante au√üerhalb dieser Funktion
    const step2_instruction = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe <b>mit einem dunkelgrauen Rahmen markiert</b>. Dr√ºcken Sie so schnell wie m√∂glich die <b>Leertaste</b>.`
      : `Finden Sie die Ziel-App im Raster und dr√ºcken Sie so schnell wie m√∂glich die <b>Leertaste</b>.`;

    const stimulus_html = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">√úbungsrunde</h2>
        <p>Wir beginnen mit einer kurzen √úbungsrunde mit ${totalPracticeTrials} Durchg√§ngen, um den Ablauf kennenzulernen. Bitte f√ºhren Sie die folgenden Schritte so schnell und genau wie m√∂glich aus:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Pr√§gen Sie sich die <b>Ziel-App</b> ein, die Ihnen jeweils gezeigt wird.</li>
          <li style="margin-bottom: 15px;">${step2_instruction}</li>
          <li style="margin-bottom: 15px;">Ein Feld mit "<b>Best√§tigen</b>" erscheint. Reagieren Sie darauf ebenfalls so schnell wie m√∂glich mit der <b>Leertaste</b>.</li>
          <li style="margin-bottom: 15px;">Anschlie√üend werden Sie zu √úbungszwecken gebeten, nacheinander sowohl die Position der <b>Ziel-App</b> als auch die Position des <b>"Best√§tigen"-Buttons</b> per Mausklick anzugeben.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">Wenn Sie bereit sind, klicken Sie auf "Weiter".</p>
      </div>
    `;

    const practiceInstructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: stimulus_html,
      choices: ['Weiter'],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      // Hinzugef√ºgte block_type-Information
      data: { trial_stage: 'practice_instruction', block_type: '√úbung' }
    };

    const practice_timeline = [practiceInstructions];

    for (let i = 0; i < totalPracticeTrials; i++) {
        // blockType '√úbung' an createSinglePracticeTrial √ºbergeben
        const single_trial_nodes = createSinglePracticeTrial(highlight, i + 1, totalPracticeTrials, '√úbung');
        practice_timeline.push(...single_trial_nodes);
        
        if (i < totalPracticeTrials - 1) {
          practice_timeline.push(getFixationTrial('√úbung')); // HIER getFixationTrial verwendet
        }
    }

    const endPractice = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="font-size: 20px; text-align: center; max-width: 800px; margin: 0 auto;">
          <p>Die √úbungsrunde ist beendet.</p>
          <p>Der Hauptblock beginnt jetzt.</p>
          <p style="margin-top: 30px;"><b>Dr√ºcken Sie die Leertaste, um fortzufahren.</b></p>
        </div>
      `,
      choices: [' '],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      // Hinzugef√ºgte block_type-Information
      data: { trial_stage: 'practice_end', block_type: '√úbung' }
    };
    practice_timeline.push(endPractice);

    return practice_timeline;
  }

  // HIER BEGINNT DIE √ÑNDERUNG F√úR DEN GESAMTEN EXPERIMENTVERLAUF (AUSSERHALB DER √úBUNGSTRIALS)
  // W√§hle 8 einzigartige App-Namen, die als ZIEL-Apps f√ºr das GESAMTE Experiment dienen werden (4 pro Block, 2 Bl√∂cke).
  // Wir ben√∂tigen 4 Ziel-Apps pro Block, und da es 2 Bl√∂cke gibt, sind das 8 Apps.
  const numTargetsPerExperiment = 8; 
  const allExperimentTargetNames = jsPsych.randomization.sampleWithoutReplacement(appNames, numTargetsPerExperiment);

  // Erstelle einen globalen Pool von App-Namen, die als DISTRAKTOREN verwendet werden k√∂nnen.
  // Dieser Pool enth√§lt ALLE urspr√ºnglichen App-Namen, AUSSER den 8 oben ausgew√§hlten Ziel-Namen.
  const globalDistractorPool = appNames.filter(name => !allExperimentTargetNames.includes(name));
  // HIER ENDET DIE √ÑNDERUNG F√úR DEN GESAMTEN EXPERIMENTVERLAUF

  // Parameter blockOrderNumber hinzugef√ºgt (wie in deinem Code) und blockType zum Durchreichen
  function makeBlockTrials(highlight, blockLabel, probeArr, blockOrderNumber) {
    const block = [];
    let probeCounter = 0;
    
    const displayBlockName = `Block ${blockOrderNumber}`;
    // Hinzugef√ºgte block_type-Information
    block.push(getInstructions(displayBlockName, highlight, blockLabel)); 
    
    // makePracticeBlock wird hier wieder aufgerufen, wie in deinem Original-Code
    // Hinweis: Dies bedeutet, dass ein √úbungsblock VOR JEDEM Hauptblock l√§uft.
    // Wenn Sie nur einen √úbungsblock am Anfang des gesamten Experiments w√ºnschen,
    // m√ºssten Sie diesen makePracticeBlock-Aufruf verschieben und nur einmal aufrufen.
    block.push(...makePracticeBlock(highlight));

    // NEU: Bestimme, welche der 8 globalen Ziel-Apps zu DIESEM spezifischen Block geh√∂ren.
    // Jeder Block erh√§lt 4 einzigartige Ziel-Apps.
    let targetsForThisBlockNames;
    if (blockOrderNumber === 1) {
        // Die ersten 4 der global ausgew√§hlten Ziel-Apps f√ºr Block 1
        targetsForThisBlockNames = allExperimentTargetNames.slice(0, 4); 
    } else { // blockOrderNumber === 2
        // Die n√§chsten 4 der global ausgew√§hlten Ziel-Apps f√ºr Block 2
        targetsForThisBlockNames = allExperimentTargetNames.slice(4, 8); 
    }
    
    const blockTargets = targetsForThisBlockNames.map(name => ({ 
        name: name, 
        symbol: symbols[Math.floor(Math.random() * symbols.length)] 
    }));

    let currentTargetIdx = 0;
    // NEU: Zeige die erste Ziel-App zu Beginn des Blocks an (blockLabel als blockType √ºbergeben)
    block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel)); 

    const allTrialIndices = Array.from({length: trialsPerBlock}, (_, k) => k);
    
    // Korrektur: Stellen Sie sicher, dass numberOfChecks mindestens 1 ist, wenn trialsPerBlock > 0
    const numberOfChecks = Math.max(1, Math.floor(trialsPerBlock * 0.25));

    const memoryCheckIndices = jsPsych.randomization.sampleWithoutReplacement(allTrialIndices, numberOfChecks);

    const checkTypes = [];
    const numAppChecks = Math.floor(numberOfChecks / 2);
    const numConfirmChecks = Math.ceil(numberOfChecks / 2); 

    for (let j = 0; j < numAppChecks; j++) {
      checkTypes.push('app_check'); 
    }
    for (let j = 0; j < numConfirmChecks; j++) {
      checkTypes.push('confirm_check'); 
    }
    
    const shuffledCheckTypes = jsPsych.randomization.shuffle(checkTypes);


    for (let i = 0; i < trialsPerBlock; i++) {
      // Ziel-App wechselt alle 10 Trials (i=10, i=20, i=30)
      // Der erste Wechsel findet bei Trial-Index 10 statt (nach 10 Trials)
      // ACHTUNG: Bei trialsPerBlock = 6 (wie in deinem Code) wird diese Bedingung
      // (i > 0 && i % 10 === 0) niemals wahr sein, da `i` nur von 0 bis 5 l√§uft.
      // Die Ziel-App wird also innerhalb des Blocks nicht wechseln.
      if (i > 0 && i % 10 === 0) { 
        currentTargetIdx++; 
        if (currentTargetIdx < blockTargets.length) {
            // blockLabel als blockType √ºbergeben
            block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel)); 
        }
      }
      
      let currentTarget = blockTargets[currentTargetIdx];
      
      // HIER IST DIE √ÑNDERUNG: Distraktoren werden nun aus dem 'globalDistractorPool' gezogen.
      // Dieser Pool enth√§lt keine der 8 Ziel-Apps des gesamten Experiments.
      let distractors = jsPsych.randomization.sampleWithoutReplacement(globalDistractorPool, 14);
      // ENDE DER √ÑNDERUNG

      let gridApps = distractors;
      gridApps.push(currentTarget.name); 
      gridApps = jsPsych.randomization.shuffle(gridApps).map(name => ({
        name,
        symbol: name === currentTarget.name ? currentTarget.symbol : symbols[Math.floor(Math.random() * symbols.length)],
        isTarget: name === currentTarget.name
      }));

      // blockLabel als blockType an getSearchTrial √ºbergeben
      block.push(getSearchTrial(
        gridApps,
        highlight,
        blockLabel, // original_block_label
        () => probeArr[probeCounter++],
        blockLabel // block_type f√ºr die CSV-Spalte
      ));

      if (memoryCheckIndices.includes(i)) {
        const checkType = shuffledCheckTypes.pop(); 

        if (checkType === 'app_check') {
          // blockLabel als blockType an getMemoryCheckTrial √ºbergeben
          block.push(getMemoryCheckTrial(false, blockLabel)); 
        } else { // 'confirm_check'
          // blockLabel als blockType an getConfirmMemoryCheckTrial √ºbergeben
          block.push(getConfirmMemoryCheckTrial(false, blockLabel)); 
        }
      }
      
      // F√ºge Fixation nur hinzu, wenn es nicht der letzte Trial im Block ist und nicht direkt vor einem Target-Wechsel
      // blockLabel als blockType an getFixationTrial √ºbergeben
      if (i < trialsPerBlock - 1 && (i + 1) % 10 !== 0) { 
         block.push(getFixationTrial(blockLabel));
      } else if (i < trialsPerBlock - 1 && (i + 1) % 10 === 0) {
        block.push(getFixationTrial(blockLabel));
      } else if (i === trialsPerBlock -1 ) {
        // Keine Fixation nach dem letzten Trial im Block
      }
    }
    return block;
  }


  // NEUE HILFSFUNKTION: Berechnet den Abstand zwischen zwei Rechtecken
  // rect = {x, y, width, height}
  function getRectDistance(rect1, rect2) {
      const r1 = {x1: rect1.x, y1: rect1.y, x2: rect1.x + rect1.width, y2: rect1.y + rect1.height};
      // KORREKTUR: Sicherstellen, dass rect2.width und rect2.height f√ºr r2 verwendet werden
      const r2 = {x1: rect2.x, y1: rect2.y, x2: rect2.x + rect2.width, y2: rect2.y + rect2.height}; 
      const dx = Math.max(0, r1.x1 - r2.x2, r2.x1 - r1.x2);
      const dy = Math.max(0, r1.y1 - r2.y2, r2.y1 - r1.y2);
      return Math.sqrt(dx * dx + dy * dy);
  }

  // Helper to get overlap area (rect = {x, y, width, height})
  function getOverlapArea(rect1, rect2) {
      const x_overlap = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x));
      const y_overlap = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
      return x_overlap * y_overlap;
  }


  const showConfirmButton = (callback, isPractice = false, probeType = null) => {
    const confirm = document.createElement('div');
    confirm.className = 'confirm-box';
    confirm.textContent = 'Best√§tigen';

    const paddingY = window.innerHeight * 0.05; 
    const paddingX = window.innerWidth * 0.05;
    
    const minimumTopInPixels = 140; 
    const topBoundary = Math.max(minimumTopInPixels, window.innerHeight * 0.10);
    
    const bottomBoundary = window.innerHeight - paddingY;
    const leftBoundary = paddingX;
    const rightBoundary = window.innerWidth - paddingX;

    // Tempor√§re Platzierung des Buttons au√üerhalb des Sichtfelds, um Gr√∂√üe zu messen
    confirm.style.position = 'absolute';
    confirm.style.left = '-1000px';
    confirm.style.top = '-1000px';
    document.body.appendChild(confirm);

    const buttonW = confirm.offsetWidth; // Tats√§chliche Breite des Buttons
    const buttonH = confirm.offsetHeight; // Tats√§chliche H√∂he des Buttons
    const buttonArea = buttonW * buttonH;
    
    // Dynamischer Mindestabstand f√ºr OFF-PROBE in Pixeln (z.B. 2vw)
    const minDistanceFromAppsForOffProbe = window.innerWidth * 0.02; // 2vw
    
    // Sicherstellen, dass probeType gesetzt ist.
    // In den Haupt-Trials wird `currentTrialProbeType` √ºbergeben, was schon ein String ist.
    // In den √úbungstrials (`isPractice = true`), muss es hier generiert werden.
    if (isPractice && !probeType) { // Nur f√ºr √úbungstrials generieren, wenn nicht bereits √ºbergeben
        probeType = Math.random() < 0.5 ? 'on-probe' : 'off-probe';
    } else if (!isPractice && !probeType) { // Fehlermeldung f√ºr Haupt-Trials, falls probeType fehlt
        console.error("showConfirmButton wurde ohne probeType im Haupt-Trial aufgerufen. Dies ist ein Fehler in der Timeline-Generierung.");
        probeType = 'off-probe'; // Fallback
    }

    let confirmX, confirmY;
    let tries = 0;
    let found = false;

    const rects = window.appRects || [];
    const nonTargetRects = rects.filter(r => !r.isTarget);
    const targetRect = rects.find(r => r.isTarget);

    while (tries < 1000 && !found) { // Max 1000 Versuche
      confirmX = leftBoundary + Math.random() * (rightBoundary - leftBoundary - buttonW);
      confirmY = topBoundary + Math.random() * (bottomBoundary - topBoundary - buttonH);

      let currentConfirmRect = { x: confirmX, y: confirmY, width: buttonW, height: buttonH };

      if (probeType === 'on-probe') {
          let hasSufficientOverlapWithNonTarget = false;
          for (let rect of nonTargetRects) {
              const overlap = getOverlapArea(currentConfirmRect, rect);
              // Pr√ºfe, ob mindestens 75% des Buttons die Nicht-Ziel-App √ºberlappen
              if (overlap / buttonArea >= 0.75) { 
                  hasSufficientOverlapWithNonTarget = true;
                  break;
              }
          }

          let overlapsTarget = false;
          if (targetRect) {
              const overlapTarget = getOverlapArea(currentConfirmRect, targetRect);
              // Pr√ºfe, ob es GAR KEINE √úberlappung (oder nur eine vernachl√§ssigbar kleine) mit der Floating-Point-Genauigkeit) mit der Ziel-App gibt
              if (overlapTarget > 0.001) { 
                  overlapsTarget = true;
              }
          }

          if (hasSufficientOverlapWithNonTarget && !overlapsTarget) {
              found = true;
          }

      } else { // probeType === 'off-probe'
          let anyOverlap = false;
          let tooCloseToApps = false;

          for (let rect of rects) { // Pr√ºfe ALLE Apps
              const overlap = getOverlapArea(currentConfirmRect, rect);
              if (overlap > 0.001) { 
                  anyOverlap = true;
                  break;
              }
              const dist = getRectDistance(currentConfirmRect, rect);
              if (dist < minDistanceFromAppsForOffProbe) { 
                  tooCloseToApps = true;
                  break;
              }
          }
          if (!anyOverlap && !tooCloseToApps) { 
              found = true;
          }
      }
      tries++;
    }

    if (!found) {
      console.warn(`Konnte keine optimale Position f√ºr den 'Best√§tigen'-Button (${probeType}) nach ${tries} Versuchen finden. Platzierung k√∂nnte suboptimal sein.`);
    }

    confirm.style.left = `${confirmX}px`;
    confirm.style.top = `${confirmY}px`;

    // confirmAppearTime kann sofort gesetzt werden
    const confirmRect = confirm.getBoundingClientRect(); 
    window.confirmPosition = { x: confirmRect.left, y: confirmRect.top };
    window.confirmAppearTime = performance.now();

    let finished = false;
    const handler = (e) => {
      if (e.code === 'Space' || e.key === ' ' || e.keyCode === 32) e.preventDefault();
      if (!finished && (e.code === 'Space' || e.key === ' ' || e.keyCode === 32)) {
        finished = true;
        const rt_confirm = performance.now() - window.confirmAppearTime;
        
        const dataToReturn = { rt_confirm: rt_confirm };
        // probe_type und confirm_tries werden nur f√ºr Haupt-Trials ben√∂tigt (oder wenn in Practice explizit gew√ºnscht)
        if (!isPractice) { 
            dataToReturn.probe_type = probeType; // Der tats√§chliche String 'on-probe' oder 'off-probe'
            dataToReturn.confirm_tries = tries;
        } else { // Auch f√ºr √úbungstrials zur√ºckgeben, falls gew√ºnscht
            dataToReturn.probe_type = probeType;
            dataToReturn.confirm_tries = tries;
        }

        confirm.remove();
        document.removeEventListener('keydown', handler, true);
        callback(dataToReturn); // Daten an den Callback zur√ºckgeben
      }
    };
    document.addEventListener('keydown', handler, true);
  };


  // === Timeline ===
  const block_definitions = [
    { highlight: false, label: "Test-Block", probes: probeArrBlock1 },
    { highlight: true, label: "Baseline-Block", probes: probeArrBlock2 }
  ];

  const randomized_blocks = jsPsych.randomization.shuffle(block_definitions);

  // Der √úbungsblock wird hier weiterhin in makeBlockTrials aufgerufen, wie in deinem Originalcode.
  // Dadurch wird er f√ºr JEDEN Hauptblock wiederholt.
  // Wenn Sie nur einen √úbungsblock am Anfang des gesamten Experiments w√ºnschen,
  // m√ºssten Sie diesen makePracticeBlock-Aufruf verschieben und nur einmal aufrufen.
  // Beispiel:
  // const timeline = [preload, startPage, ...makePracticeBlock(false)];
  // timeline.push(...firstBlock, ...secondBlock);
  // jsPsych.run(timeline);

  const firstBlock = makeBlockTrials(
    randomized_blocks[0].highlight,
    randomized_blocks[0].label,
    randomized_blocks[0].probes,
    1 // Dieser Block ist immer "Block 1"
  );

  const secondBlock = makeBlockTrials(
    randomized_blocks[1].highlight,
    randomized_blocks[1].label,
    randomized_blocks[1].probes,
    2 // Dieser Block ist immer "Block 2"
  );
  
  // Kombiniere alle Teile in der finalen Timeline
  const timeline = [preload, startPage, ...firstBlock, ...secondBlock];

  jsPsych.run(timeline);
</script>
</body>
</html>