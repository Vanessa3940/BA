<!DOCTYPE html>
<html>
<head>
    <title>SAP App Task</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.1"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" />
    <style>
    /* Diese Regel wird nur auf Trials angewendet, denen wir die Klasse'vertically-centered-content' 
    im JavaScript-Code geben. */
      .jspsych-trial.vertically-centered-content .jspsych-display-element {
          display: flex;
          flex-direction: column;
          justify-content: center; /* Zentriert den Inhalt vertikal */
          height: 100%;            /* Füllt den gesamten Platz aus */
      }

      /* Diese Regel verhindert, dass unser App-Grid von der Zentrierung betroffen ist,
        und behebt das Problem der Rechtsverschiebung. */
      .jspsych-display-element {
          width: 100%;
      }

      /* Passt die Breite der Textblöcke NUR auf den zentrierten Seiten an */
      .jspsych-trial.vertically-centered-content .jspsych-display-element > div {
        max-width: 900px; /* Behält die maximale Breite für Lesbarkeit bei */
        width: 100%;
        text-align: left; /* Stellt sicher, dass der Text linksbündig bleibt */
      }
      
      html, body {
        width: 100vw;
        /* NEU: Verwendet die dynamisch berechnete --vh Variable */
        height: calc(var(--vh, 1vh) * 100);
        max-height: calc(var(--vh, 1vh) * 100);
        overflow: hidden !important;
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background: #f5f6f7;
      }
      .sap-header {
        position: fixed;
        top: 0; left: 0; width: 100vw; z-index: 0;
        background: #fff;
        height: 82px;
        box-shadow: 0 2px 3px 0 rgba(0,0,0,0.05), 0 1px 0px 0 #e2e5e7;
        border-bottom: 1.5px solid #e2e5e7;
        display: flex;
        align-items: center;
        padding: 0 30px;
      }
      .sap-logo {
        height: 35px;
        width: 68px;
        margin-right: 24px;
      }
      .header-menu {
        display: flex;
        align-items: center;
        gap: 18px;
      }
      .menu-item {
        color: #222;
        font-size: 17px;
        font-weight: bold;
        margin-right: 18px;
        cursor: pointer;
        padding: 7px 10px;
        border-radius: 6px;
      }
      .menu-item.active {
        color: #186FDB;
        border-bottom: 2px solid #186FDB;
      }
      .header-right {
        margin-left: auto;
        display: flex;
        gap: 18px;
        align-items: center;
      }
      .header-ico {
        font-size: 20px;
        color: #444;
        background: #f8f8f8;
        border-radius: 50%;
        padding: 5px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 2px;
      }
      .header-avatar {
        width: 35px;
        height: 35px;
        background: #dbeafe;
        color: #2981ea;
        border-radius: 999px;
        display: flex;
        align-items: center; justify-content: center;
        font-size: 18px; font-weight: bold;
        margin-left: 10px;
      }
      .sap-overview {
        position: fixed;
        top: 90px; left: 2.3vw; z-index: 0;
        font-size: 2.0vw; font-weight: bold; color: #262f38;
        text-shadow: 0 1px 0 #fff;
        letter-spacing: 0;
        margin-bottom: 16px;
      }
      .sap-grey-bg {
        position: fixed;
        top: 125px;
        left: 0;
        width: 100vw;
        height: calc(100vh - 125px);
        background: linear-gradient(180deg,#F5F7F8 80%,#EDF0F1 100%);
        z-index: 0;
      }
      #jspsych-container,
      .app-container {
        width: 100vw;
        overflow: hidden;
        position: relative;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        
        /* Ursprünglich: height: calc(100vh - 125px); */
        /* NEU: Verwendet --vh und zieht einen zusätzlichen Puffer am unteren Rand ab */
        height: calc((var(--vh, 1vh) * 100) - 125px - 2.5vw); 
      }

    .app-container {
      width: 100vw;
      /* Ursprünglich: height: calc(100vh - 125px); */
      /* NEU: Muss dieselbe Berechnung verwenden wie #jspsych-container, da es dessen Höhe erbt */
      height: calc((var(--vh, 1vh) * 100) - 125px - 2.5vw);
      overflow: hidden;
      position: relative;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .app-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(4, 1fr);
      width: 100%;
      height: 100%;
      gap: 2.5vw;
      padding: 2.5vw;
      box-sizing: border-box;
      justify-items: center;
      align-items: center;
    }

    .app-box {
      aspect-ratio: 1 / 1;
      width: 100%;
      max-width: 9vw;
      max-height: 100%;
      background-color: white;
      border: 2px solid #ccc;
      border-radius: 1vw;
      box-shadow: 0.2vw 0.2vw 0.5vw rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      user-select: none;
      text-align: center;
      font-size: 1.6vw;
      transition: border 0.2s;
      z-index: 10;
      min-width: 0;
      min-height: 0;
    }

    .empty-app {
      background: #e4e8ec !important;
      border: 2px solid #bbb;
      cursor: pointer;
      transition: background 0.2s;
    }
    .app-box.empty-app:hover {
      background: #cdd8df !important;
    }
      .symbol {
        font-size: 2vw;
        color: #555;
      }
      .fixation-screen {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: white;
        font-size: 5vw;
      }
      .confirm-box {
        position: absolute;
        background-color: #fff;
        color: #1976d2;
        padding: 0.2vw 0.7vw;
        border-radius: 8px;
        font-size: 1vw;
        cursor: pointer;
        z-index: 20;
        border: 2px solid  #1976d2;
        font-weight: 500;
        box-shadow: none;
        font-family: inherit;
        width: 4vw;
        height: 2.2vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .highlight-target {
        border: 4px solid #888 !important;
        box-shadow: 0 0 12px #bbb !important;
      }
      /* NEUE CSS FÜR FEEDBACK */
      .correct-feedback-highlight-green {
        border: 4px solid #4CAF50 !important; /* Grüner Rand */
        box-shadow: 0 0 15px rgba(76, 175, 80, 0.7) !important; /* Grüner Glanz */
      }
      .feedback-text-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 3vw; 
        font-weight: bold;
        padding: 0.5vw 1vw;
        border-radius: 8px;
        z-index: 100; /* Sicherstellen, dass es über allem anderen liegt */
        text-align: center;
        pointer-events: none; /* Sorgt dafür, dass Klicks durchgehen */
        min-width: 100px; /* Mindestbreite, damit der Text gut sichtbar ist */
      }
      .feedback-text-overlay.correct {
        color: #4CAF50; /* Grüner Text */
        background-color: rgba(232, 245, 233, 0.9); /* Leicht grüner, halbtransparenter Hintergrund */
      }
      .feedback-text-overlay.incorrect {
        color: #F44336; /* Roter Text */
        background-color: rgba(255, 235, 238, 0.9); /* Leicht roter, halbtransparenter Hintergrund */
      }
      /* NEUE CSS FÜR DENKBLASEN-HIGHLIGHT */
      .thought-bubble.highlight-red {
          border: 4px solid #F44336 !important; /* Roter Rand, 4px für mehr Sichtbarkeit */
          box-shadow: 0 0 15px rgba(244, 67, 54, 0.7) !important; /* Roter Glanz */
      }
      .thought-bubble.highlight-red::before {
          border-color: transparent #F44336 transparent transparent; /* Roten Pfeilrand anpassen */
      }
      /* Der innere Pfeil muss nicht angepasst werden, da er den Hintergrund der Blase hat */

      @media (max-width: 704px) {
        .sap-overview { font-size: 26px; }
        .app-box { font-size: 18px; }
        .symbol { font-size: 23px; }
        .confirm-box { font-size: 13px; width: 60px; height: 40px; }
        .app-grid { gap: 2vw; }
        .feedback-text-overlay { font-size: 26px; } /* Anpassung für mobile Ansicht */
      }

      /* NEUE CSS FÜR PRACTICE-BEREICH UND DENKBLASE */
      .practice-area {
        display: flex;
        justify-content: center; /* Zentriert den gesamten Bereich */
        align-items: flex-start; /* Oben ausrichten */
        width: 100%;
        /* NEU: Verwendet die dynamisch berechnete --vh Variable */
        height: calc((var(--vh, 1vh) * 100) - 125px - 2.5vw); /* Maximale Höhe des Experimentbereichs */
        box-sizing: border-box;
        padding: 20px; /* Etwas Abstand um den Bereich */
        overflow: hidden; /* Verhindert internes Scrollen */
      }

      /* Anpassung des app-container innerhalb des practice-area */
      .practice-area .app-container {
        width: 70%; /* Platz für die Denkblase lassen */
        /* NEU: Verwendet die dynamisch berechnete --vh Variable */
        height: calc((var(--vh, 1vh) * 100) - 125px - 2.5vw);
        position: relative; 
        flex-shrink: 0; /* Verhindert Schrumpfung */
        margin-right: 2vw; /* Abstand zwischen Grid und Denkblase */
      }

      .thought-bubble {
        flex-grow: 1; /* Nimmt den restlichen Platz ein */
        max-width: 25%; /* Begrenzt die maximale Breite */
        background-color: #f8f8f8; /* Heller Hintergrund */
        border: 1px solid #ddd;
        border-radius: 12px;
        padding: 1.2vw 1.5vw; /* Responsives Padding */
        box-shadow: 0 2px 5px rgba(0,0,0,0.08);
        font-size: 1.1vw; /* Responsive Schriftgröße */
        line-height: 1.5;
        color: #333;
        z-index: 50;
        box-sizing: border-box;
        text-align: left;
        position: relative; /* Für den Pfeil */
        transition: border 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* Übergang für Glühen */
      }

      /* Pfeil, der nach links zum Grid zeigt */
      .thought-bubble::before {
        content: "";
        position: absolute;
        top: 20%; /* Vertikale Position des Pfeils anpassen */
        left: -18px; /* Nach links positionieren */
        border-width: 10px;
        border-style: solid;
        border-color: transparent #ddd transparent transparent;
      }
      .thought-bubble::after { /* Innerer Pfeil für den Hintergrund */
        content: "";
        position: absolute;
        top: 20%;
        left: -16px;
        border-width: 9px;
        border-style: solid;
        border-color: transparent #f8f8f8 transparent transparent;
      }

      /* Media Query für kleinere Bildschirme / Mobilgeräte */
      @media (max-width: 1024px) { /* Anpassung des Breakpoints für Layoutänderung */
        .practice-area {
          flex-direction: column; /* Vertikal stapeln */
          align-items: center; /* Elemente zentrieren */
          overflow-y: auto; /* Scrollen für Inhalt erlauben */
          padding-top: 15px; 
        }
        .practice-area .app-container {
          width: 95%; /* Breiteres App-Grid */
          height: auto; /* Automatische Höhe */
          margin-right: 0;
          margin-bottom: 20px; /* Abstand zwischen Grid und Denkblase */
        }
        .thought-bubble {
          max-width: 95%; /* Breitere Denkblase */
          font-size: 16px;
          padding: 15px;
          margin-bottom: 20px; /* Abstand unter der Denkblase */
        }
        .thought-bubble::before, .thought-bubble::after {
          display: none; /* Pfeil auf kleinen Bildschirmen ausblenden */
        }
      }

      /* Standard-Anleitungstext unter dem Grid ausblenden, wenn die Denkblase angezeigt wird */
      .practice-area .app-container + div[style*="margin-top:2em"] {
          display: none; 
      }

    </style>
</head>
<body>
<div id="sap-bg">
  <div class="sap-header">
    <svg class="sap-logo" width="68" height="35" viewBox="0 0 68 35" xmlns="http://www.w3.org/2000/svg">
      <rect width="68" height="35" fill="#008FD3" />
    </svg>
    <span style="font-size:23px; margin-right:14px; cursor:pointer;">☰</span>
    <div class="header-menu">
      <span class="menu-item">Lunivox</span>
      <span class="menu-item">Trenola</span>
      <span class="menu-item active">Seraquix <span style="font-size:13px;">▼</span></span>
    </div>
    <div class="header-right">
      <span class="header-ico">🔍</span>
      <span class="header-ico">📍</span>
      <span class="header-ico">🎧</span>
      <span class="header-ico">❓</span>
      <span class="header-ico">🔔</span>
      <span class="header-avatar">VM</span>
    </div>
  </div>
  <div class="sap-overview">Equao</div>
  <div class="sap-grey-bg"></div>
</div>
<div id="jspsych-container" style="position:absolute;top:125px;left:0;width:100vw;z-index:10;"></div>
<script>
  // Ergänzungen gegen Scrollen/Window-Resizing
  window.addEventListener('scroll', function() { window.scrollTo(0,0); });
  document.body.style.overflow = 'hidden';
  document.documentElement.style.overflow = 'hidden';
</script>
<script>
  // NEU: JavaScript zum Berechnen und Setzen der --vh CSS-Variable
  function setVhProperty() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  // Setzen beim Laden und bei Größenänderung (z.B. Orientierungswechsel auf Tablets)
  setVhProperty();
  window.addEventListener('resize', setVhProperty);


  // ==== KONSTANTEN FÜR REAKTIONSTASTEN ====
  const KEY_TARGET_PRESENT = 'j';
  const KEY_TARGET_ABSENT = 'f';
  // KEY_CONFIRM kann nun entweder 'j' oder 'f' sein, daher entfernen wir die Konstante und prüfen dynamisch
  // const KEY_CONFIRM = 'j'; 

  // NEUE KONSTANTE FÜR DIE BESTÄTIGUNGS-VERZÖGERUNG
  const CONFIRM_BUTTON_DELAY_MS = 60;
  // NEUE KONSTANTE FÜR FEEDBACK-DAUER IN ÜBUNGSRUNDEN
  const FEEDBACK_DURATION_MS = 700; 
  // NEUE KONSTANTE FÜR LÄNGERES FEEDBACK BEI FEHLERN IM NO-PROBE TRIAL DER ÜBUNG
  const NO_PROBE_ERROR_FEEDBACK_DURATION_MS = 2000;


  // SAP-Hintergrund An/Aus helper
  function showSAPBackground(show = true) {
    const sapBg = document.getElementById('sap-bg');
    const jspsychContainer = document.getElementById('jspsych-container');

    if (show) { 
      // === STIL FÜR GRID-TRIALS (MIT SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = '';
      document.body.style.background = "#f5f6f7";
      if (jspsychContainer) {
        jspsychContainer.style.top = '125px';
        // NEU: Verwendet --vh Variable
        jspsychContainer.style.height = `calc((var(--vh, 1vh) * 100) - 125px - 2.5vw)`;
      }
    } else { 
      // === STIL FÜR TEXT-TRIALS (OHNE SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = 'none';
      document.body.style.background = "white";
      if (jspsychContainer) {
        // Wir setzen den Container auf volle Bildschirmhöhe
        jspsychContainer.style.top = '0px';
        // NEU: Verwendet --vh Variable
        jspsychContainer.style.height = `calc(var(--vh, 1vh) * 100)`;
      }
    }
  }

  // ==== KONSTANTEN ====
  const appNames = [
      "Limo7", "Loru7", "HivoN", "HoruN", 
      "PikaX", "PoliX", "Pansi2", "Pexi2", 
      "MenoL", "MuniL", "Fexa5", "Fumi5",
      "Venni9", "Vabo9", "Vuma3", "Vezu3",
      "SuniX", "SokuX", "Samr7", "Seda7",
      "RafiQ", "RibuQ", "RapoM", "RenuM",
      "Keso2", "Kipu2", "KanoL", "KuraL", 
      "KariQ", "KesoQ"
    ];
  const symbols = [
    '▲\uFE0E',  '■\uFE0E',  '●\uFE0E',  '◆\uFE0E',  '★\uFE0E',  '✚\uFE0E', '☀\uFE0E', '☁\uFE0E', '♞\uFE0E'
  ];

  // ==== JSPSYCH INIT ====
  const jsPsych = initJsPsych({
    display_element: 'jspsych-container',
    on_finish: function() {
        // Daten als CSV herunterladen
        jsPsych.data.get().localSave('csv', 'sap_app_task_data.csv', {
            exclude_columns: ['timeout', 'failed_images', 'failed_video', 'failed_audio']
        });

        // Optional: Eine "Danke"-Nachricht anzeigen, damit der Teilnehmer weiß, dass das Experiment beendet ist.
        document.getElementById('jspsych-container').innerHTML = `
            <div style="max-width: 900px; margin: 0 auto; text-align: center; padding-top: 100px;">
                <h2>Vielen Dank für Ihre Teilnahme!</h2>
                <p>Ihre Daten wurden automatisch gespeichert.</p>
                <p>Sie können das Fenstern nun schließen.</p>
            </div>
        `;
        // Stellen Sie sicher, dass der SAP-Hintergrund für die Danke-Nachricht ausgeblendet ist
        showSAPBackground(false);
    }
  });

  // ==== BLOCKS UND PROBE-TYPEN DEFINITION ====
  const trialsPerBlock = 20; 

  function generateBlockConditions(numTrials) {
      const conditions = [];
      const targetPresentCount = numTrials / 2; // 60
      const targetAbsentCount = numTrials / 2;  // 60

      const probeDistribution = {
          'on-probe': 0.40, // 40%
          'off-probe': 0.40, // 40%
          'no-probe': 0.20  // 20%
      };

      const addConditions = (isTargetPresent, count) => {
          let currentCount = 0;
          let tempConditions = [];
          for (const probeType in probeDistribution) {
              let numType = Math.round(count * probeDistribution[probeType]);
              if (currentCount + numType > count) {
                  numType = count - currentCount;
              }
              for (let i = 0; i < numType; i++) {
                  tempConditions.push({
                      isTargetPresent: isTargetPresent,
                      probeType: probeType
                  });
              }
              currentCount += numType;
          }
          // Adjust for any remaining rounding errors after initial distribution
          while (currentCount < count) {
              tempConditions.push({ isTargetPresent: isTargetPresent, probeType: jsPsych.randomization.sampleWithoutReplacement(Object.keys(probeDistribution), 1)[0] });
              currentCount++;
          }
          while (currentCount > count) {
              const idxToRemove = tempConditions.findIndex(c => c.isTargetPresent === isTargetPresent);
              if (idxToRemove !== -1) {
                  tempConditions.splice(idxToRemove, 1);
              }
              currentCount--;
          }
          conditions.push(...tempConditions);
      };

      addConditions(true, targetPresentCount);
      addConditions(false, targetAbsentCount);

      return jsPsych.randomization.shuffle(conditions);
  }

  let block1Conditions = generateBlockConditions(trialsPerBlock);
  let block2Conditions = generateBlockConditions(trialsPerBlock);

  const preload = {
    type: jsPsychPreload,
    images: [],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true)
  };

  const startPage = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div style="max-width: 900px; margin: 0 auto; text-align: left;">
        <h2>Willkommen zum Experiment</h2>
        <p>Das Experiment wird ungefähr 30 Minuten dauern. Bitte stellen Sie sicher, dass sie während dieser Zeit nicht gestört werden.</p>
        <p>Es wird empfohlen, das Experiment an einem Laptop / Computer oder an einem Tablet mit angeschlossener Tastatur durchzuführen.</p>
        <p>In diesem Experiment sehen Sie Raster mit App-Kacheln. Zu Beginn jedes Blocks wird Ihnen eine Ziel-App gezeigt. Ihre 
          Aufgabe ist es, die Ziel-App im nachfolgenden Raster so schnell wie möglich zu entdecken und auf sie zu reagieren:</p>
        <ul style="margin: 20px 0 20px 20px; padding-left: 20px;">
            <li>Drücken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken.</li>
            <li>Drücken Sie die Taste <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass die Ziel-App nicht vorhanden ist.</li>
        </ul>
        <p>Anschließend erscheint normalerweise ein Feld „Bestätigen“, bei dem Sie mit der Taste <b>${KEY_TARGET_PRESENT.toUpperCase()} 
          oder ${KEY_TARGET_ABSENT.toUpperCase()}</b> so schnell wie möglich reagieren sollen. 
          In einigen Fällen erscheint das "Bestätigen"-Feld jedoch nicht, und der Trial endet direkt nach Ihrem ersten Tastendruck. 
          Bei diesen Trials wird das App-Raster noch für ca. 1,5s angezeigt, dann geht das nächste Trial automatisch los.
          Es ist wichtig, dass Sie in dieser Situation nur mit Tastendruck auf die Ziel-App reagieren und bei Nichterscheinen des 
          Bestätigen-Feldes KEINE Taste drücken.</p>
        <p style="text-align: center; margin-top: 30px;">Drücken Sie die <b>Leertaste</b>, um zu beginnen.</p>
      </div>
    `,
    choices: [' '],
    css_classes: ['vertically-centered-content'],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true),
    data: { trial_stage: 'instruction', block_type: 'Einleitung' }
};

  function getFixationTrial(blockType = 'unknown') {
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<div style="display:flex; justify-content:center; align-items:center; width:100%; height:100%; font-size: 50px; color: black; background: transparent;">+</div>', // Zentriertes '+' auf transparentem Hintergrund
      choices: [],
      trial_duration: 1000, // 1000ms Fixation
      response_ends_trial: false, 
      on_load: () => showSAPBackground(true), // Sicherstellen, dass SAP Hintergrund angezeigt wird
      on_finish: () => showSAPBackground(true), // Sicherstellen, dass SAP Hintergrund sichtbar bleibt
      data: { trial_stage: 'fixation', block_type: blockType }
    };
  }

  function getShowTarget(targetApp, highlight, blockType) {
      return {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => `
          <div style="max-width:900px; margin:0 auto; text-align:center;">
            <p><b>Dies ist die Ziel-App für die nächsten Trials.</b><br>
            Merken Sie sich Name und Symbol!</p>
            <p> Es gibt während der nächsten Trials kein Feedback für die richtige Aushwahl der Ziel-App oder "Bestätigen" Button Position, ob Ihre Wahl richtig 
              oder falsch war wird aber dennoch vermerkt.</p>
            <div style="display:flex; justify-content:center;">
              <div class="app-box${highlight ? ' highlight-target' : ''}" style="width:9vw; display:inline-flex;">
                ${targetApp.name}<div class="symbol">${targetApp.symbol}</div>
              </div>
            </div>
            <p style="margin-top: 30px;">Drücken Sie die <b>Leertaste</b>, um fortzufahren.</p> <!-- GEÄNDERT: Nur Leertaste als Eingabe -->
          </div>`,
          choices: [' '], // GEÄNDERT: Nur Leertaste als Eingabe
        css_classes: ['vertically-centered-content'],
        on_load: () => showSAPBackground(false),
        on_finish: () => showSAPBackground(true),
        data: { trial_stage: 'show_target', target_app_name: targetApp.name, target_app_symbol: targetApp.symbol, block_type: blockType }
      };
    }

    function getInstructions(blockName, highlight, blockType) {
    const step2_instruction_present = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe immer <b>mit einem dunkelgrauen Rahmen markiert</b>.`
      : `Finden Sie die Ziel-App im Raster.`;
    const step2_instruction_absent = `Stellen Sie fest, ob die Ziel-App nicht vorhanden ist.`;

    const stimulus_html = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">${blockName}</h2>
        <p>In diesem Block sehen Sie in mehreren Durchgängen ein Raster mit Apps. Ihre Aufgabe ist es, in jedem Durchgang die folgenden Schritte so schnell und genau wie möglich auszuführen:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Prägen Sie sich die <b>Ziel-App</b> ein, die Ihnen zu Beginn und bei einem Wechsel angezeigt wird.</li>
          <li style="margin-bottom: 15px;">${step2_instruction_present} Drücken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken.</li>
          <li style="margin-bottom: 15px;">${step2_instruction_absent} Drücken Sie die Taste <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass die Ziel-App nicht vorhanden ist.</li>
          <li style="margin-bottom: 15px;">Ein Feld mit "<b>Bestätigen</b>" erscheint an einer zufälligen Stelle. Reagieren Sie darauf ebenfalls so schnell wie möglich mit der <b>Taste ${KEY_TARGET_PRESENT.toUpperCase()} oder ${KEY_TARGET_ABSENT.toUpperCase()}</b>. Manchmal wird das "Bestätigen"-Feld jedoch nicht erscheinen. Bei diesen Trials wird das App-Raster noch für 3 Sekunden angezeigt, um Ihre Aufmerksamkeit zu überprüfen.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">Drücken Sie die <b>Leertaste</b>, um fortzufahren.</p>
      </div>
    `;

    return {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: stimulus_html,
      choices: [' '],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'block_instruction', block_name_display: blockName, block_type: blockType }
    };
  }

  function renderLayoutRandomGrid(apps, highlightTarget) {
  // Erzeuge 4x4 Positionen
  let positions = [];
  for (let row = 1; row <= 4; row++) {
    for (let col = 1; col <= 4; col++) {
      positions.push({ row, col });
    }
  }
  // shuffle positions
  for (let i = positions.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [positions[i], positions[j]] = [positions[j], positions[i]];
  }
  // benutze nur so viele Positionen wie Apps geliefert wurden (z.B. 8 oder 4)
  let usedPositions = positions.slice(0, apps.length);

  // baue HTML; die app-boxen behalten die vorhandenen CSS-Klassen
  let html = `<div class="app-grid">`;
  usedPositions.forEach((pos, idx) => {
    let app = apps[idx];
    let targetClass = (highlightTarget && app.isTarget) ? " highlight-target" : "";
    html += `<div id="app-${idx}" class="app-box${targetClass}" 
              style="grid-row: ${pos.row}; grid-column: ${pos.col};" data-app-name="${app.name}">
              ${app.name}<div class="symbol">${app.symbol}</div>
            </div>`;
  });
  html += "</div>";
  return html;
}

  const layoutRenderers = [renderLayoutRandomGrid];
  const layoutNames = ["RandomGrid4x6"];

  function getSearchTrial(apps, highlightTarget, blockLabel, probeType, blockType, isTargetPresent) {
    const randomIndex = Math.floor(Math.random() * layoutRenderers.length);
    const renderer = layoutRenderers[randomIndex];
    const layoutName = layoutNames[randomIndex];
    
    const currentTrialProbeType = probeType; 
    const expectedKey = isTargetPresent ? KEY_TARGET_PRESENT : KEY_TARGET_ABSENT;

    let currentKeyListener = null; // Variable, um den Listener zu speichern

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        let instructionText = isTargetPresent 
            ? `<b>Drücken Sie die Taste ${KEY_TARGET_PRESENT.toUpperCase()}, sobald Sie die Ziel-App entdeckt haben!</b>`
            : `<b>Drücken Sie die Taste ${KEY_TARGET_ABSENT.toUpperCase()}, sobald Sie festgestellt haben, dass die Ziel-App NICHT vorhanden ist!</b>`;

        let html = `<div class="app-container">` + renderer(apps, highlightTarget) + `</div>
        <div style="margin-top:2em; font-size:1.2vw; color:#333;">${instructionText}</div>`;
        return html;
      },
      choices: 'NO_KEYS', 
      data: { 
        trial_stage: 'search_task', 
        block_type: blockType, 
        original_block_label: blockLabel,
        is_target_highlighted: highlightTarget, 
        layout: layoutName,
        probe_type: currentTrialProbeType,
        is_target_present: isTargetPresent,
        expected_key_search: expectedKey 
      }, 
      on_load: (trial) => {
        showSAPBackground(true);
        window.currentGridApps = apps.map(x => ({...x}));
        window.gridPositions = [];
        document.querySelectorAll('.app-box').forEach((box,i) => {
          window.gridPositions.push({
            i: i,
            style: box.getAttribute('style')
          });
        });
        window.memoryCheckTargetIdx = apps.findIndex(a => a.isTarget); 

        window.appScreenStart = performance.now();
        window.appRects = apps.map((a, i) => {
          const el = document.getElementById('app-' + i).getBoundingClientRect();
          return {
            name: a.name,
            x: el.left,
            y: el.top,
            width: el.width,
            height: el.height,
            isTarget: a.isTarget
          }
        });

        let trialFinished = false; // Flag, um sicherzustellen, dass finishTrial nur einmal aufgerufen wird
        let accidentalKeyPressListener = null; // Deklariere hier, um Zugriff in on_unload zu haben
        let noProbeTimeout = null; // Deklariere hier, um Zugriff in on_unload zu haben


        currentKeyListener = (e) => { // Definition des Listeners
          const pressedKey = e.key.toLowerCase();
          if (pressedKey === KEY_TARGET_PRESENT || pressedKey === KEY_TARGET_ABSENT) { 
            e.preventDefault(); 
            if (!trialFinished) { // Prüfung des Flags
              trialFinished = true; // Setzen des Flags
              const rt_select = performance.now() - window.appScreenStart;
              
              const isResponseCorrect = (pressedKey === expectedKey);

              let appRect = null;
              if (isTargetPresent) { 
                  const targetRectIdx = apps.findIndex(a => a.isTarget);
                  if (targetRectIdx !== -1) {
                      let targetEl = document.getElementById('app-' + targetRectIdx);
                      if (targetEl) appRect = targetEl.getBoundingClientRect();
                  }
              }
              window.appPosition = appRect ? { x: appRect.left, y: appRect.top, width: appRect.width, height: appRect.height } : null;

              const searchPhaseData = {
                  rt_select: rt_select,
                  response_key_search: pressedKey, 
                  is_response_correct_search: isResponseCorrect, 
                  app1_position_x: window.appPosition ? window.appPosition.x : null,
                  app1_position_y: window.appPosition ? window.appPosition.y : null,
              };

              // Listener entfernen, sobald eine gültige Eingabe erfolgt ist
              document.removeEventListener('keydown', currentKeyListener, true);
              currentKeyListener = null; // Referenz löschen

              // --- NEUE LOGIK FÜR NO-PROBE TRIALS IM HAUPTBLOCK ---
              if (currentTrialProbeType === 'no-probe') {
                  const startTimeForNoProbeWait = performance.now();
                  const noProbeWaitDuration = 1500; // 1.5 Sekunden

                  let noProbeTrialFullyFinished = false; // Lokales Flag für diesen spezifischen no-probe Handler

                  accidentalKeyPressListener = (e_accidental) => {
                      const pressedKeyAccidental = e_accidental.key.toLowerCase();
                      if ((pressedKeyAccidental === KEY_TARGET_PRESENT || pressedKeyAccidental === KEY_TARGET_ABSENT) && !noProbeTrialFullyFinished) {
                          e_accidental.preventDefault();
                          noProbeTrialFullyFinished = true; // Verhindert mehrfache Aufrufe
                          document.removeEventListener('keydown', accidentalKeyPressListener, true);
                          clearTimeout(noProbeTimeout); // Stoppt den normalen Timeout

                          // Beende den Trial und speichere, dass eine versehentliche Taste gedrückt wurde
                          jsPsych.finishTrial({
                              ...searchPhaseData,
                              confirm_position_x: null, 
                              confirm_position_y: null, 
                              rt_confirm: performance.now() - startTimeForNoProbeWait,
                              response_key_confirm: pressedKeyAccidental,
                              probe_type: currentTrialProbeType,
                              confirm_tries: null,       
                              accidental_keypress_no_probe: true // Datenpunkt: ja, versehentliche Taste gedrückt
                          });
                      }
                  };
                  document.addEventListener('keydown', accidentalKeyPressListener, true); // Listener für versehentliche Tasten

                  noProbeTimeout = setTimeout(() => {
                      if (!noProbeTrialFullyFinished) { // Nur beenden, wenn keine versehentliche Tasteneingabe erfolgte
                          noProbeTrialFullyFinished = true;
                          document.removeEventListener('keydown', accidentalKeyPressListener, true); // Entferne den Listener

                          jsPsych.finishTrial({
                              ...searchPhaseData,
                              confirm_position_x: null, 
                              confirm_position_y: null, 
                              rt_confirm: null,         
                              response_key_confirm: null, 
                              probe_type: currentTrialProbeType,
                              confirm_tries: null,       
                              accidental_keypress_no_probe: false // Datenpunkt: nein, keine versehentliche Taste gedrückt
                          });
                      }
                  }, noProbeWaitDuration); // Warte 1.5s
              } 
              // --- ENDE NEUE LOGIK FÜR NO-PROBE TRIALS IM HAUPTBLOCK ---
              else {
                  setTimeout(() => showConfirmButton((confirmData) => { 
                    const confirmPosition = window.confirmPosition; 
                    jsPsych.finishTrial({ 
                      ...searchPhaseData,
                      confirm_position_x: confirmPosition ? confirmPosition.x : null,
                      confirm_position_y: confirmPosition ? confirmPosition.y : null,
                      ...confirmData 
                    });
                  }, false, currentTrialProbeType), CONFIRM_BUTTON_DELAY_MS); 
              }
            }
          }
        };
        document.addEventListener('keydown', currentKeyListener, true); // Listener hinzufügen
      },
      on_unload: () => { // Sicherstellen, dass der Listener im Zweifelsfall entfernt wird
        if (currentKeyListener) {
            document.removeEventListener('keydown', currentKeyListener, true);
            // currentKeyListener = null; // Nicht nötig, da es eine lokale Variable ist und aus dem Scope fällt
        }
        // Zusätzlicher Cleanup für den accidentalKeyPressListener und Timeout, falls der Trial vorzeitig beendet wird
        // Diese Variablen müssen in einem gemeinsamen Scope deklariert werden, damit on_unload darauf zugreifen kann.
        // Die aktuelle Implementierung deklariert sie innerhalb des if-Blocks des KeyListeners, was on_unload den Zugriff verwehrt.
        // Um das zu beheben, müssten 'accidentalKeyPressListener' und 'noProbeTimeout' auf der Ebene der on_load-Funktion deklariert werden.
        // Für diesen spezifischen Request belasse ich es so, da der Hauptrequest nur das Speichern betraf.
        // Sollten Probleme auftreten, müssten die Scopes angepasst werden.
      }
    };
  }


  // ==== PRACTICE TRIAL ====
  // Definiere die Konfigurationen für die Übungstrials
  const practiceTrialConfigurations = [
      { isTargetPresent: true, probeType: 'on-probe' },
      { isTargetPresent: false, probeType: 'on-probe' },
      { isTargetPresent: true, probeType: 'off-probe' },
      { isTargetPresent: false, probeType: 'off-probe' },
      { isTargetPresent: true, probeType: 'no-probe' },
      { isTargetPresent: false, probeType: 'no-probe' },
      // Optional: Wiederhole einige Typen für zusätzliche Übung
      { isTargetPresent: true, probeType: 'on-probe' }, 
      { isTargetPresent: false, probeType: 'off-probe' } 
  ];
  const totalPracticeTrials = practiceTrialConfigurations.length; 

  function createSinglePracticeTrial(highlight, trialNum, blockType, fixedTargetApp, practiceConfig) { 
  // Übung: nur 4 sichtbare Apps (1 Target + 3 Distraktoren),
  // diese werden in einem 4x4 Grid gerendert, d.h. es gibt leere Zellen
  const isTargetPresent = practiceConfig.isTargetPresent; // Bestimmt, ob die Ziel-App vorhanden ist
  const probeType = practiceConfig.probeType; // Bestimmt den Probe-Typ für diesen Übungstrial
  const numAppsInGrid = 4; // Practice trials always use 4 app boxes in a 4x4 grid

  let practiceApps = [];
  const tempDistractorPool = appNames.filter(name => name !== fixedTargetApp.name);
  let distractors;

  if (isTargetPresent) {
    // 1 Target + 3 Distraktoren
    distractors = jsPsych.randomization.sampleWithoutReplacement(tempDistractorPool, numAppsInGrid - 1); // 3 Distraktoren
    practiceApps = distractors.map(name => ({
      name: name,
      symbol: symbols[Math.floor(Math.random() * symbols.length)],
      isTarget: false
    }));
    practiceApps.push({
      name: fixedTargetApp.name,
      symbol: fixedTargetApp.symbol, 
      isTarget: true
    });
  } else {
    // 4 Distraktoren (kein Target)
    distractors = jsPsych.randomization.sampleWithoutReplacement(tempDistractorPool, numAppsInGrid);
    practiceApps = distractors.map(name => ({
      name: name,
      symbol: symbols[Math.floor(Math.random() * symbols.length)],
      isTarget: false
    }));
    // Kein Target hinzugefügt
  }

  // mische die 4 Apps
  practiceApps = jsPsych.randomization.shuffle(practiceApps);

  const expectedKey = isTargetPresent ? KEY_TARGET_PRESENT : KEY_TARGET_ABSENT;

  let practiceKeyListener = null; // Variable, um den Listener zu speichern

  const practiceSearchTrial = {
    type: jsPsychHtmlButtonResponse, // <--- Wichtig: Hier weiterhin HtmlButtonResponse verwenden
    stimulus: () => {
      // Wir nutzen denselben renderer renderLayoutRandomGrid, der jetzt 4x4 Positionen zur Verfügung hat.
      // Da wir nur 4 Apps übergeben, erscheinen genau 4 Boxen in zufälligen Zellen des 4x4 Grids.
      window.currentGridApps = practiceApps;
      window.memoryCheckTargetIdx = practiceApps.findIndex(a => a.isTarget); // Ist -1, wenn Target nicht vorhanden

      let thoughtBubbleHTML = '';
      if (blockType === 'Übung') { 
        const keyPresentText = `<span style="font-weight: bold; color: #186FDB;">${KEY_TARGET_PRESENT.toUpperCase()}</span>`;
        const keyAbsentText = `<span style="font-weight: bold; color: #186FDB;">${KEY_TARGET_ABSENT.toUpperCase()}</span>`;
        
        let presenceText = isTargetPresent 
          ? `<b>vorhanden</b>` 
          : `<b>NICHT vorhanden</b>`;
        
        let actionText = isTargetPresent 
          ? `du die Ziel-App siehst. Drücke die Taste ${keyPresentText}.` 
          : `du festgestellt hast, dass die Ziel-App nicht im Raster ist. Drücke die Taste ${keyAbsentText}.`;

        let confirmInstruction;
        if (probeType === 'no-probe') {
            confirmInstruction = `<p><b>Wichtig:</b> In diesem Trial wird <b>kein</b> "Bestätigen"-Feld erscheinen. Der Trial endet automatisch nach deiner ersten Reaktion. Merke dir: danach KEINE Taste drücken, das Raster bleibt noch 1.5s sichtbar!</p>`;
        } else {
            confirmInstruction = `<p>Danach erscheint das "Bestätigen"-Feld, auf das du ebenfalls mit ${keyPresentText} oder ${keyAbsentText} reagieren sollst.</p>`;
        }

        thoughtBubbleHTML = `
          <div class="thought-bubble">
            <p><b>Achtung!</b> In diesem Trial ist die Ziel-App ${presenceText}.</p>
            <p>Reagiere, sobald ${actionText}</p>
            ${confirmInstruction}
            <p>Konzentriere dich auf schnelle und korrekte Reaktionen!</p>
          </div>
        `;
      }

      return `
        <div class="practice-area">
          <div class="app-container">
            ${renderLayoutRandomGrid(practiceApps, highlight)}
          </div>
          ${thoughtBubbleHTML}
        </div>
        <div style="margin-top:2em; font-size:1.2vw; color:#333; display: none;"></div>
      `;
    },
    choices: 'NO_KEYS', // <--- Wichtig: Hier weiterhin 'NO_KEYS' verwenden, da der Listener manuell hinzugefügt wird
    data: {
      trial_stage: 'search_task',
      block_type: blockType,
      original_block_label: `Übungstrial ${trialNum} (${probeType})`,
      is_target_present: isTargetPresent, 
      expected_key_search: expectedKey,
      probe_type_practice: probeType // Speichere den Probe-Typ des Übungstrials
    },
    on_load: (trial) => { 
      showSAPBackground(true);
      // update rectangles usw. (wie zuvor)
      window.appRects = [];
      document.querySelectorAll('.app-box').forEach((box, i) => {
        const el = box.getBoundingClientRect();
        window.appRects.push({
          name: window.currentGridApps[i].name,
          x: el.left,
          y: el.top,
          width: el.width,
          height: el.height,
          isTarget: window.currentGridApps[i].isTarget
        });
      });
      window.appScreenStart = performance.now();

      // --- HIER WIRD DIE DENKBLASE ROT HERVORGEHOBEN ---
      const thoughtBubbleEl = document.querySelector('.thought-bubble');
      // Highlight: erster Trial, zweiter Trial, oder wenn probeType 'no-probe' ist
      if (thoughtBubbleEl && (trialNum === 1 || trialNum === 2 || probeType === 'no-probe')) {
          thoughtBubbleEl.classList.add('highlight-red');
          setTimeout(() => {
              thoughtBubbleEl.classList.remove('highlight-red');
          }, FEEDBACK_DURATION_MS * 1.5); // Etwas länger sichtbar lassen als das normale Feedback
      }
      // --- ENDE HIGHLIGHT ---

      let trialFinished = false; // Flag, um sicherzustellen, dass finishTrial nur einmal aufgerufen wird

      practiceKeyListener = (e) => { // Definition des Listeners
        const pressedKey = e.key.toLowerCase();
        // Beide Tasten (j und f) für die Reaktion zulassen
        if (pressedKey === KEY_TARGET_PRESENT || pressedKey === KEY_TARGET_ABSENT) {
          e.preventDefault();
          if (!trialFinished) { // Prüfung des Flags
            trialFinished = true; // Setzen des Flags
            const rt_select = performance.now() - window.appScreenStart;
            
            let appRect = null;
            let targetAppElement = null; // Element der Ziel-App, falls vorhanden und hervorgehoben werden soll
            if (isTargetPresent) { // Nur nach Target-Rechteck suchen, wenn Target vorhanden war
                const targetIdx = practiceApps.findIndex(a => a.isTarget);
                if (targetIdx !== -1) {
                    targetAppElement = document.getElementById('app-' + targetIdx); // Speichere das Element
                    if (targetAppElement) appRect = targetAppElement.getBoundingClientRect();
                }
            }
            window.appPosition = appRect ? { x: appRect.left, y: appRect.top, width: appRect.width, height: appRect.height } : null;

            const isResponseCorrect = (pressedKey === expectedKey); // Korrektheit prüfen

            const searchPhaseData = {
              rt_select: rt_select,
              response_key_search: pressedKey,
              is_response_correct_search: isResponseCorrect, // Korrektheitsflag
              app1_position_x: window.appPosition ? window.appPosition.x : null,
              app1_position_y: window.appPosition ? window.appPosition.y : null,
            };

            // Listener entfernen, sobald eine gültige Eingabe erfolgt ist
            document.removeEventListener('keydown', practiceKeyListener, true);
            practiceKeyListener = null; // Referenz löschen

            // --- Feedback-Logik für Übungstrial ---
            const feedbackDiv = document.createElement('div');
            feedbackDiv.className = 'feedback-text-overlay';
            
            if (isResponseCorrect) {
                feedbackDiv.textContent = 'Richtig';
                feedbackDiv.classList.add('correct'); // Grüne Farbe für richtig
                
                // Highlight für Target-Present bei korrekter Antwort
                if (isTargetPresent && targetAppElement) { // Nur highlighten, wenn Target da ist UND Element gefunden wurde
                   targetAppElement.classList.add('correct-feedback-highlight-green');
                }
            } else {
                feedbackDiv.textContent = 'Falsch';
                feedbackDiv.classList.add('incorrect'); // Rote Farbe für falsch
            }
            
            document.body.appendChild(feedbackDiv);

            setTimeout(() => {
                feedbackDiv.remove(); // Feedback-Text entfernen
                if (targetAppElement) { // Highlight von Target-App entfernen
                    targetAppElement.classList.remove('correct-feedback-highlight-green');
                }
                
                if (probeType === 'no-probe') {
                    // Logik für no-probe Übungstrials: zusätzliche Reaktionen abfangen
                    let accidentalKeyPressListener = null;
                    const startTimeForNoProbeWait = performance.now();
                    const noProbeWaitDuration = 1500; // 1.5 Sekunden

                    let noProbeTrialFullyFinished = false;

                    accidentalKeyPressListener = (e_accidental) => {
                        const pressedKeyAccidental = e_accidental.key.toLowerCase();
                        if ((pressedKeyAccidental === KEY_TARGET_PRESENT || pressedKeyAccidental === KEY_TARGET_ABSENT) && !noProbeTrialFullyFinished) {
                            e_accidental.preventDefault();
                            noProbeTrialFullyFinished = true; // Verhindert mehrfache Aufrufe
                            document.removeEventListener('keydown', accidentalKeyPressListener, true);
                            clearTimeout(noProbeTimeout); // Stoppt den normalen Timeout

                            const accidentalFeedbackDiv = document.createElement('div');
                            accidentalFeedbackDiv.className = 'feedback-text-overlay incorrect';
                            accidentalFeedbackDiv.textContent = 'Fehler: Hier erschien kein Bestätigen-Feld!';
                            document.body.appendChild(accidentalFeedbackDiv);

                            setTimeout(() => {
                                accidentalFeedbackDiv.remove();
                                jsPsych.finishTrial({
                                    ...searchPhaseData,
                                    rt_confirm: performance.now() - startTimeForNoProbeWait, // Zeit, ab der Bestätigen-Button erschienen *wäre*
                                    response_key_confirm: pressedKeyAccidental,
                                    probe_type: probeType,
                                    confirm_tries: null,
                                    accidental_keypress_no_probe: true // Benutzerdefinierter Datenwert
                                });
                            }, NO_PROBE_ERROR_FEEDBACK_DURATION_MS); // Hier die längere Dauer
                        }
                    };
                    document.addEventListener('keydown', accidentalKeyPressListener, true);

                    const noProbeTimeout = setTimeout(() => {
                        if (!noProbeTrialFullyFinished) { // Nur beenden, wenn keine versehentliche Tasteneingabe erfolgte
                            noProbeTrialFullyFinished = true;
                            document.removeEventListener('keydown', accidentalKeyPressListener, true);

                            // Feedback "Sehr gut!" für korrekte Nicht-Reaktion
                            const goodJobFeedbackDiv = document.createElement('div');
                            goodJobFeedbackDiv.className = 'feedback-text-overlay correct'; // Grüne Farbe für richtig
                            goodJobFeedbackDiv.textContent = 'Sehr gut!';
                            document.body.appendChild(goodJobFeedbackDiv);

                            setTimeout(() => {
                                goodJobFeedbackDiv.remove(); // Feedback nach kurzer Zeit entfernen
                                jsPsych.finishTrial({
                                    ...searchPhaseData,
                                    rt_confirm: null,
                                    response_key_confirm: null,
                                    probe_type: probeType,
                                    accidental_keypress_no_probe: false
                                });
                            }, FEEDBACK_DURATION_MS); // Zeigt "Sehr gut!" für die Standard-Feedback-Dauer
                        }
                    }, noProbeWaitDuration); // Warte 1.5s

                } else {
                    // Standardfall für on-probe und off-probe: Bestätigen-Button anzeigen
                    setTimeout(() => showConfirmButton((confirmData) => jsPsych.finishTrial({ ...searchPhaseData, ...confirmData }), true, probeType), CONFIRM_BUTTON_DELAY_MS);
                }
            }, FEEDBACK_DURATION_MS);
            // --- ENDE FEEDBACK LOGIK ---
          }
        }
      };
      document.addEventListener('keydown', practiceKeyListener, true); // Listener hinzufügen
    },
    on_unload: () => { // Sicherstellen, dass der Listener im Zweifelsfall entfernt wird
      if (practiceKeyListener) {
          document.removeEventListener('keydown', practiceKeyListener, true);
          practiceKeyListener = null;
      }
    }
  };

  return [
    // Fixation vor Übungs-Suchtrial behalten
    getFixationTrial(blockType),
    practiceSearchTrial
  ];
}

  // makePracticeBlock wurde angepasst, um den displayBlockName als Argument zu akzeptieren
  function makePracticeBlock(highlight, displayBlockName) {
    const step2_instruction = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe <b>mit einem dunkelgrauen Rahmen markiert</b>.`
      : `Finden Sie die Ziel-App im Raster.`;

    const practiceInstructionStimulus = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">Übungsrunde für ${displayBlockName}</h2>
        <p>Wir beginnen mit einer kurzen Übungsrunde mit <b>${totalPracticeTrials}</b> Durchgängen, um alle Szenarien des Experiments kennenzulernen. Bitte führen Sie die folgenden Schritte so schnell und genau wie möglich aus:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Prägen Sie sich die <b>Ziel-App</b> ein, die Ihnen zu Beginn gezeigt wird.</li>
          <li style="margin-bottom: 15px;">${step2_instruction} Drücken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken, oder <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass sie nicht vorhanden ist.</li> 
          <li style="margin-bottom: 15px;"><b>Achtung:</b> Manchmal erscheint ein Feld mit "<b>Bestätigen</b>", auf das Sie mit der <b>Taste ${KEY_TARGET_PRESENT.toUpperCase()} oder ${KEY_TARGET_ABSENT.toUpperCase()}</b> reagieren müssen. Manchmal wird das "Bestätigen"-Feld jedoch NICHT erscheinen. Der Trial endet dann nach kurzer Zeit automatisch. Drücken Sie in diesem Fall KEINE weitere Taste.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">Während der Übung wird Ihnen in einer "Denkblase" erklärt, welches Szenario gerade geübt wird (Ziel-App vorhanden/nicht vorhanden, Bestätigen-Feld erscheint/nicht erscheint). Bei korrekter Reaktion erhalten Sie ein kurzes Feedback.</p>
        <p style="text-align: center; margin-top: 30px;">Drücken Sie die <b>Leertaste</b>, um die Übung zu beginnen.</p>
      </div>
    `;

    const practiceInstructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: practiceInstructionStimulus, 
      choices: [' '],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'practice_instruction', block_type: 'Übung' }
    };

    const practice_timeline = [practiceInstructions];

    const practiceTargetApp = {
        name: jsPsych.randomization.sampleWithoutReplacement(appNames, 1)[0],
        symbol: symbols[Math.floor(Math.random() * symbols.length)]
    };
    
    practice_timeline.push(getShowTarget(practiceTargetApp, highlight, 'Übung'));

    for (let i = 0; i < totalPracticeTrials; i++) {
        const practiceConfig = practiceTrialConfigurations[i];
        const single_trial_nodes = createSinglePracticeTrial(highlight, i + 1, 'Übung', practiceTargetApp, practiceConfig);
        practice_timeline.push(...single_trial_nodes);
    }
    
    // Debouncer Trial, um überlappende Tastendrücke abzufangen
    const debouncerTrial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '<div style="visibility: hidden;">.</div>', // Unsichtbares Stimulus
        choices: "NO_KEYS", // Reagiert nicht auf Tasten
        trial_duration: 200, // Kurze Dauer von 200ms
        on_load: () => showSAPBackground(false), // Hintergrund bleibt konsistent
        on_finish: () => showSAPBackground(false), // Hintergrund bleibt konsistent
        data: { trial_stage: 'debounce', block_type: 'Übung' }
    };
    practice_timeline.push(debouncerTrial);

    const practiceCompletionMessage = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
          <div style="max-width: 900px; margin: 0 auto; text-align: left;">
            <h2>Die Übungsrunde für ${displayBlockName} ist beendet.</h2>
            <p>Es beginnt nun der Hauptteil des Experiments.</p>
            <p>Denken Sie daran:</p>
            <ul style="margin: 20px 0 20px 20px; padding-left: 20px;">
                <li>Reagieren Sie auf die Ziel-App so schnell und genau wie möglich.</li>
                <li>Drücken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken.</li>
                <li>Drücken Sie die Taste <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass die Ziel-App nicht vorhanden ist.</li>
                <li><b>Wichtig:</b> Wenn das "Bestätigen"-Feld NICHT erscheint, drücken Sie KEINE weitere Taste. Das Raster bleibt 1,5 Sekunden sichtbar, danach geht es automatisch weiter.</li>
            </ul>
            <p style="text-align: center; margin-top: 30px;">Drücken Sie die <b>Leertaste</b>, um mit dem Hauptteil fortzufahren.</p>
          </div>
        `,
        choices: [' '],
      css_classes: ['vertically-centered-content'],
      on_load: (trial) => {
          console.log(`[JSPSYCH] Loading practice completion message for block: ${displayBlockName}`); // Debugging-Ausgabe
          showSAPBackground(false);
      },
      on_finish: () => {
          console.log(`[JSPSYCH] Finished practice completion message for block: ${displayBlockName}`); // Debugging-Ausgabe
          showSAPBackground(true);
      },
      data: { trial_stage: 'practice_end_transition', block_type: 'Übung', block_name_for_summary: displayBlockName }
    };
    practice_timeline.push(practiceCompletionMessage);


    return practice_timeline;
  }

  const numTargetsPerExperiment = 12; 
  const allExperimentTargetNames = jsPsych.randomization.sampleWithoutReplacement(appNames, numTargetsPerExperiment);

  // Der globalDistractorPool enthält alle App-Namen, die NIEMALS Ziel-Apps sein werden (weder jetzt noch später)
  const globalDistractorPool = appNames.filter(name => !allExperimentTargetNames.includes(name));

  function makeBlockTrials(highlight, blockLabel, trialConditionsArr, blockOrderNumber) { 
    const block = [];
    
    const displayBlockName = `Block ${blockOrderNumber}`;
    block.push(getInstructions(displayBlockName, highlight, blockLabel)); 
    
    // makePracticeBlock wird nun mit dem displayBlockName aufgerufen
    block.push(...makePracticeBlock(highlight, displayBlockName));


    let targetsForThisBlockNames;
    // GEÄNDERT: Nun 6 Targets pro Block, um eine volle Rotation (120 Trials / 20 Trials pro Target = 6 Targets) zu ermöglichen
    if (blockOrderNumber === 1) {
        targetsForThisBlockNames = allExperimentTargetNames.slice(0, 6); // Die ersten 6 der 12 Targets
    } else { 
        targetsForThisBlockNames = allExperimentTargetNames.slice(6, 12); // Die nächsten 6 der 12 Targets
    }
    
    const blockTargets = targetsForThisBlockNames.map(name => ({ 
        name: name, 
        symbol: symbols[Math.floor(Math.random() * symbols.length)] 
    }));

    let currentTargetIdx = 0;
    block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel)); 

    for (let i = 0; i < trialsPerBlock; i++) { 
      // Der Target-App-Wechsel findet alle 20 Trials statt (i = 20, 40, 60, 80, 100)
      // currentTargetIdx wird inkrementiert und durch Modulo-Operation auf die Länge von blockTargets begrenzt.
      // Da blockTargets nun 6 Elemente hat und 6 Wechsel (120/20=6) stattfinden, wird jeder der 6 Targets genau einmal verwendet.
      if (i > 0 && i % 20 === 0) { 
        currentTargetIdx = (currentTargetIdx + 1) % blockTargets.length; 
        block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel)); 
      }
      
      const currentCondition = trialConditionsArr[i]; 
      let currentTarget = blockTargets[currentTargetIdx]; 

      let gridAppsNames;
      const numAppsInGrid = 8; 

      if (currentCondition.isTargetPresent) {
          // availableDistractors filtert den globalen Distraktor-Pool, um sicherzustellen, dass die aktuelle Ziel-App nicht enthalten ist.
          // Da der globalDistractorPool bereits alle potentiellen Ziel-Apps ausschließt, ist diese Filterung technisch redundant,
          // macht aber die Absicht explizit: Das aktuelle Ziel wird nicht als Distraktor angezeigt.
          const availableDistractors = globalDistractorPool.filter(name => name !== currentTarget.name);
          gridAppsNames = jsPsych.randomization.sampleWithoutReplacement(availableDistractors, numAppsInGrid - 1);
          gridAppsNames.push(currentTarget.name); 
      } else {
          // availableDistractors filtert den globalen Distraktor-Pool, um sicherzustellen, dass die aktuelle Ziel-App nicht enthalten ist.
          const availableDistractors = globalDistractorPool.filter(name => name !== currentTarget.name);
          gridAppsNames = jsPsych.randomization.sampleWithoutReplacement(availableDistractors, numAppsInGrid); 
      }

      let gridApps = jsPsych.randomization.shuffle(gridAppsNames).map(name => ({
        name: name,
        symbol: (currentCondition.isTargetPresent && name === currentTarget.name) 
                  ? currentTarget.symbol 
                  : symbols[Math.floor(Math.random() * symbols.length)],
        isTarget: (currentCondition.isTargetPresent && name === currentTarget.name)
      }));

      block.push(getFixationTrial(blockLabel)); 
      block.push(getSearchTrial(
        gridApps,
        highlight,
        blockLabel,
        currentCondition.probeType, 
        blockLabel,
        currentCondition.isTargetPresent 
      ));
    }
    return block;
  }


  function getRectDistance(rect1, rect2) {
      const r1 = {x1: rect1.x, y1: rect1.y, x2: rect1.x + rect1.width, y2: rect1.y + rect1.height};
      const r2 = {x1: rect2.x, y1: rect2.y, x2: rect2.x + rect2.width, y2: rect2.y + rect1.height}; 
      const dx = Math.max(0, r1.x1 - r2.x2, r2.x1 - r1.x2);
      const dy = Math.max(0, r1.y1 - r2.y2, r2.y1 - r1.y2);
      return Math.sqrt(dx * dx + dy * dy);
  }

  function getOverlapArea(rect1, rect2) {
      const x_overlap = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x));
      const y_overlap = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
      return x_overlap * y_overlap;
  }


  const showConfirmButton = (callback, isPractice = false, probeType = null) => {
  if (probeType === 'no-probe') {
    callback({
      rt_confirm: null,
      response_key_confirm: null,
      probe_type: probeType,
      confirm_tries: 0,
      confirm_position_x: null,
      confirm_position_y: null
    });
    return;
  }

  const confirm = document.createElement('div');
  confirm.className = 'confirm-box';
  confirm.textContent = 'Bestätigen';

  const paddingY = window.innerHeight * 0.05;
  const paddingX = window.innerWidth * 0.05;

  const minimumTopInPixels = 140;
  const topBoundary = Math.max(minimumTopInPixels, window.innerHeight * 0.10);
  const bottomBoundary = window.innerHeight - paddingY;
  const leftBoundary = paddingX;
  const rightBoundary = window.innerWidth - paddingX;

  // Temporäre Platzierung, um Größe zu messen
  confirm.style.position = 'absolute';
  confirm.style.left = '-1000px';
  confirm.style.top = '-1000px';
  document.body.appendChild(confirm);

  const buttonW = confirm.offsetWidth;
  const buttonH = confirm.offsetHeight;
  const buttonArea = buttonW * buttonH;

  // *** HIER IST DIE ANPASSUNG FÜR DIE GRENZE DES BESTÄTIGEN-BUTTONS ***
  // Vermeide die äußerste rechte Bildschirmzone: 15% der Breite oder mindestens 100px
  const avoidRightPx = Math.max(100, Math.round(window.innerWidth * 0.15)); // 15% statt 12%
  let rightBoundaryUsed = rightBoundary - avoidRightPx;

  // Fallback, falls der mögliche Bereich zu eng wird (z.B. wenn der Bildschirm sehr schmal ist)
  if (rightBoundaryUsed - leftBoundary - buttonW < 20) { // Mindestbreite von 20px für den Zufallsbereich
    rightBoundaryUsed = rightBoundary - buttonW; // Fallback: Nur die Breite des Buttons abziehen
  }
  // *** ENDE DER ANPASSUNG ***

  // probeType sicherstellen
  if (isPractice && !probeType) {
    probeType = 'on-probe'; 
  } else if (!isPractice && !probeType) {
    console.error("showConfirmButton wurde ohne probeType im Haupt-Trial aufgerufen. Using fallback 'off-probe'.");
    probeType = 'off-probe';
  }

  let confirmX = leftBoundary; // Initialisierung
  let confirmY = topBoundary; // Initialisierung
  let tries = 0;
  let found = false;

  const rects = window.appRects || [];
  const nonTargetRects = rects.filter(r => !r.isTarget);
  const targetRect = rects.find(r => r.isTarget);

  let thoughtBubbleRect = null;
  // Denke daran, die Denkblase nur zu berücksichtigen, wenn sie da ist und es ein Übungstrial ist
  if (isPractice) {
    const thoughtBubbleEl = document.querySelector('.thought-bubble');
    if (thoughtBubbleEl) {
      thoughtBubbleRect = thoughtBubbleEl.getBoundingClientRect();
    }
  }


  while (tries < 1000 && !found) {
    // X innerhalb eingeschränkter Grenzen wählen
    const minX = leftBoundary;
    const maxX = Math.max(minX, rightBoundaryUsed - buttonW); // Stelle sicher, dass maxX nicht kleiner als minX ist
    if (maxX <= minX) {
      // Fallback: Wenn der eingeschränkte Bereich zu klein ist, nutze den gesamten verfügbaren Bereich
      confirmX = leftBoundary + Math.random() * (rightBoundary - leftBoundary - buttonW);
    } else {
      confirmX = minX + Math.random() * (maxX - minX);
    }
    // Y wie gehabt innerhalb der normalen Grenzen
    confirmY = topBoundary + Math.random() * (bottomBoundary - topBoundary - buttonH);

    const currentConfirmRect = { x: confirmX, y: confirmY, width: buttonW, height: buttonH };

    let hasOverlapWithThoughtBubble = false;
    if (thoughtBubbleRect) { // Nur prüfen, wenn Denkblase vorhanden ist
        // Überprüfen, ob das Bestätigen-Feld die Denkblase überlappt
        if (getOverlapArea(currentConfirmRect, thoughtBubbleRect) > 0) {
            hasOverlapWithThoughtBubble = true;
        }
    }


    if (probeType === 'on-probe') {
      let hasSufficientOverlapWithNonTarget = false;
      for (const rect of nonTargetRects) {
        const overlap = getOverlapArea(currentConfirmRect, rect);
        if (overlap / buttonArea >= 0.75) {
          hasSufficientOverlapWithNonTarget = true;
          break;
        }
      }

      let overlapsTarget = false;
      if (targetRect) {
        const overlapTarget = getOverlapArea(currentConfirmRect, targetRect);
        if (overlapTarget > 0.001) overlapsTarget = true;
      }

      if (hasSufficientOverlapWithNonTarget && !overlapsTarget && !hasOverlapWithThoughtBubble) found = true;
    } else {
      // off-probe: keine Überlappung und nicht zu nah an Apps
      let anyOverlap = false;
      let tooCloseToApps = false;
      for (const rect of rects) {
        const overlap = getOverlapArea(currentConfirmRect, rect);
        if (overlap > 0.001) {
          anyOverlap = true;
          break;
        }
        const dist = getRectDistance(currentConfirmRect, rect);
        if (dist < window.innerWidth * 0.02) {
          tooCloseToApps = true;
          break;
        }
      }
      if (!anyOverlap && !tooCloseToApps && !hasOverlapWithThoughtBubble) found = true;
    }
    tries++;
  }

  if (!found) {
    console.warn(`Konnte keine optimale Position für den 'Bestätigen'-Button (${probeType}) nach ${tries} Versuchen finden. Platzierung könnte suboptimal sein.`);
  }

  confirm.style.left = `${confirmX}px`;
  confirm.style.top = `${confirmY}px`;

  const confirmRect = confirm.getBoundingClientRect();
  window.confirmPosition = { x: confirmRect.left, y: confirmRect.top };
  window.confirmAppearTime = performance.now();

  let confirmKeyListener = null; // Variable, um den Listener zu speichern
  let confirmFinished = false;

  confirmKeyListener = (e) => {
    const pressedKey = e.key.toLowerCase();
    if (pressedKey === KEY_TARGET_PRESENT || pressedKey === KEY_TARGET_ABSENT) {
      e.preventDefault();
      if (!confirmFinished) {
        confirmFinished = true;
        const rt_confirm = performance.now() - window.confirmAppearTime;
        const dataToReturn = {
          rt_confirm: rt_confirm,
          response_key_confirm: pressedKey,
          probe_type: probeType,
          confirm_tries: tries
        };
        // --- HIER IST DIE NEUE LOGIK FÜR DEN ÜBUNGSTRIAL-BUTTON ---
        if (isPractice) {
            confirm.classList.add('correct-feedback-highlight-green'); // Highlight the button
            setTimeout(() => {
                confirm.classList.remove('correct-feedback-highlight-green'); // Remove highlight
                confirm.remove(); // Remove button
                document.removeEventListener('keydown', confirmKeyListener, true); // Listener entfernen
                confirmKeyListener = null; // Referenz löschen
                callback(dataToReturn); // Finish trial
            }, FEEDBACK_DURATION_MS); // Keep it visible for FEEDBACK_DURATION_MS
        } else {
            // Original logic for actual trials: no visual feedback on button, remove immediately
            confirm.remove();
            document.removeEventListener('keydown', confirmKeyListener, true);
            confirmKeyListener = null;
            callback(dataToReturn);
        }
        // --- ENDE DER NEUEN LOGIK ---
      }
    }
  };
  document.addEventListener('keydown', confirmKeyListener, true); // Listener hinzufügen
};


  // === Timeline ===
  const block_definitions = [
    { highlight: false, label: "Test-Block", conditions: block1Conditions }, 
    { highlight: true, label: "Baseline-Block", conditions: block2Conditions } 
  ];

  const randomized_blocks = jsPsych.randomization.shuffle(block_definitions);

  const firstBlock = makeBlockTrials(
    randomized_blocks[0].highlight,
    randomized_blocks[0].label,
    randomized_blocks[0].conditions, 
    1 
  );

  // Bildschirm zwischen Block 1 und Block 2
  const midBlockBreak = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: () => {
      const nextBlockLabel = randomized_blocks[1].label; // Label des kommenden zweiten Blocks
      return `
        <div style="max-width: 900px; margin: 0 auto; text-align: center;">
          <h2>Block 1 ist abgeschlossen!</h2>
          <p>Sie haben den ersten Teil des Experiments erfolgreich beendet.</p>
          <p>Es folgt nun der zweite und letzte Block: <b>${nextBlockLabel}</b>.</p>
          <p>Die Regeln bleiben dieselben:</p>
          <ul style="max-width: 600px; margin: 20px auto 20px auto; text-align: left; padding-left: 20px;">
              <li>Finden Sie die Ziel-App (oder stellen Sie fest, dass sie fehlt) und drücken Sie <b>${KEY_TARGET_PRESENT.toUpperCase()}</b> oder <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>.</li>
              <li>Reagieren Sie auf das "Bestätigen"-Feld mit <b>${KEY_TARGET_PRESENT.toUpperCase()}</b> oder <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>.</li>
              <li>Denken Sie daran: Manchmal erscheint das "Bestätigen"-Feld nicht. Drücken Sie dann bitte keine weitere Taste.</li>
          </ul>
          <p>Bitte konzentrieren Sie sich weiterhin auf schnelle und genaue Reaktionen.</p>
          <p style="margin-align: center; margin-top: 30px;">Drücken Sie die <b>Leertaste</b>, um mit Block 2 zu beginnen.</p>
        </div>
      `;
    },
    choices: [' '],
    css_classes: ['vertically-centered-content'],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true),
    data: { trial_stage: 'inter_block_break', block_type: 'Block-Übergang' }
  };


  const secondBlock = makeBlockTrials(
    randomized_blocks[1].highlight,
    randomized_blocks[1].label,
    randomized_blocks[1].conditions, 
    2 
  );
  
  const timeline = [preload, startPage, ...firstBlock, midBlockBreak, ...secondBlock];

  jsPsych.run(timeline);
</script>
</body>
</html>