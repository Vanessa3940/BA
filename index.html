<!DOCTYPE html>
<html>
<head>
    <title>SAP App Task</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.1"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" />
    <style>
    /* Diese Regel wird nur auf Trials angewendet, denen wir die Klasse'vertically-centered-content' 
    im JavaScript-Code geben. */
      .jspsych-trial.vertically-centered-content .jspsych-display-element {
          display: flex;
          flex-direction: column;
          justify-content: center; /* Zentriert den Inhalt vertikal */
          height: 100%;            /* F√ºllt den gesamten Platz aus */
      }

      /* Diese Regel verhindert, dass unser App-Grid von der Zentrierung betroffen ist,
        und behebt das Problem der Rechtsverschiebung. */
      .jspsych-display-element {
          width: 100%;
      }

      /* Passt die Breite der Textbl√∂cke NUR auf den zentrierten Seiten an */
      .jspsych-trial.vertically-centered-content .jspsych-display-element > div {
        max-width: 900px; /* Beh√§lt die maximale Breite f√ºr Lesbarkeit bei */
        width: 100%;
        text-align: left; /* Stellt sicher, dass der Text linksb√ºndig bleibt */
      }
      
      html, body {
        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;
        overflow: hidden !important;
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background: #f5f6f7;
      }
      .sap-header {
        position: fixed;
        top: 0; left: 0; width: 100vw; z-index: 0;
        background: #fff;
        height: 82px;
        box-shadow: 0 2px 3px 0 rgba(0,0,0,0.05), 0 1px 0px 0 #e2e5e7;
        border-bottom: 1.5px solid #e2e5e7;
        display: flex;
        align-items: center;
        padding: 0 30px;
      }
      .sap-logo {
        height: 35px;
        width: 68px;
        margin-right: 24px;
      }
      .header-menu {
        display: flex;
        align-items: center;
        gap: 18px;
      }
      .menu-item {
        color: #222;
        font-size: 17px;
        font-weight: bold;
        margin-right: 18px;
        cursor: pointer;
        padding: 7px 10px;
        border-radius: 6px;
      }
      .menu-item.active {
        color: #186FDB;
        border-bottom: 2px solid #186FDB;
      }
      .header-right {
        margin-left: auto;
        display: flex;
        gap: 18px;
        align-items: center;
      }
      .header-ico {
        font-size: 20px;
        color: #444;
        background: #f8f8f8;
        border-radius: 50%;
        padding: 5px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 2px;
      }
      .header-avatar {
        width: 35px;
        height: 35px;
        background: #dbeafe;
        color: #2981ea;
        border-radius: 999px;
        display: flex;
        align-items: center; justify-content: center;
        font-size: 18px; font-weight: bold;
        margin-left: 10px;
      }
      .sap-overview {
        position: fixed;
        top: 90px; left: 2.3vw; z-index: 0;
        font-size: 2.0vw; font-weight: bold; color: #262f38;
        text-shadow: 0 1px 0 #fff;
        letter-spacing: 0;
        margin-bottom: 16px;
      }
      .sap-grey-bg {
        position: fixed;
        top: 125px;
        left: 0;
        width: 100vw;
        height: calc(100vh - 125px);
        background: linear-gradient(180deg,#F5F7F8 80%,#EDF0F1 100%);
        z-index: 0;
      }
      #jspsych-container,
      .app-container {
        width: 100vw;
        height: calc(100vh - 125px);
        overflow: hidden;
        position: relative;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

    .app-container {
      width: 100vw;
      height: calc(100vh - 125px);
      overflow: hidden;
      position: relative;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .app-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(4, 1fr);
      width: 100%;
      height: 100%;
      gap: 2.5vw;
      padding: 2.5vw;
      box-sizing: border-box;
      justify-items: center;
      align-items: center;
    }

    .app-box {
      aspect-ratio: 1 / 1;
      width: 100%;
      max-width: 9vw;
      max-height: 100%;
      background-color: white;
      border: 2px solid #ccc;
      border-radius: 1vw;
      box-shadow: 0.2vw 0.2vw 0.5vw rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      user-select: none;
      text-align: center;
      font-size: 1.6vw;
      transition: border 0.2s;
      z-index: 10;
      min-width: 0;
      min-height: 0;
    }

    .empty-app {
      background: #e4e8ec !important;
      border: 2px solid #bbb;
      cursor: pointer;
      transition: background 0.2s;
    }
    .app-box.empty-app:hover {
      background: #cdd8df !important;
    }
      .symbol {
        font-size: 2vw;
        color: #555;
      }
      .fixation-screen {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: white;
        font-size: 5vw;
      }
      .confirm-box {
        position: absolute;
        background-color: #fff;
        color: #1976d2;
        padding: 0.2vw 0.7vw;
        border-radius: 8px;
        font-size: 1vw;
        cursor: pointer;
        z-index: 20;
        border: 2px solid  #1976d2;
        font-weight: 500;
        box-shadow: none;
        font-family: inherit;
        width: 4vw;
        height: 2.2vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .highlight-target {
        border: 4px solid #888 !important;
        box-shadow: 0 0 12px #bbb !important;
      }
      @media (max-width: 704px) {
        .sap-overview { font-size: 26px; }
        .app-box { font-size: 18px; }
        .symbol { font-size: 23px; }
        .confirm-box { font-size: 13px; width: 60px; height: 40px; }
        .app-grid { gap: 2vw; }
      }
    </style>
</head>
<body>
<div id="sap-bg">
  <div class="sap-header">
    <svg class="sap-logo" width="68" height="35" viewBox="0 0 68 35" xmlns="http://www.w3.org/2000/svg">
      <rect width="68" height="35" fill="#008FD3" />
    </svg>
    <span style="font-size:23px; margin-right:14px; cursor:pointer;">‚ò∞</span>
    <div class="header-menu">
      <span class="menu-item">Lunivox</span>
      <span class="menu-item">Trenola</span>
      <span class="menu-item active">Seraquix <span style="font-size:13px;">‚ñº</span></span>
    </div>
    <div class="header-right">
      <span class="header-ico">üîç</span>
      <span class="header-ico">üìç</span>
      <span class="header-ico">üéß</span>
      <span class="header-ico">‚ùì</span>
      <span class="header-ico">üîî</span>
      <span class="header-avatar">VM</span>
    </div>
  </div>
  <div class="sap-overview">Equao</div>
  <div class="sap-grey-bg"></div>
</div>
<div id="jspsych-container" style="position:absolute;top:125px;left:0;width:100vw;height:calc(100vh - 125px);z-index:10;"></div>
<script>
  // Erg√§nzungen gegen Scrollen/Window-Resizing
  window.addEventListener('scroll', function() { window.scrollTo(0,0); });
  document.body.style.overflow = 'hidden';
  document.documentElement.style.overflow = 'hidden';
</script>
<script>
  // ==== KONSTANTEN F√úR REAKTIONSTASTEN ====
  const KEY_TARGET_PRESENT = 'j';
  const KEY_TARGET_ABSENT = 'f';
  // KEY_CONFIRM kann nun entweder 'j' oder 'f' sein, daher entfernen wir die Konstante und pr√ºfen dynamisch
  // const KEY_CONFIRM = 'j'; 

  // NEUE KONSTANTE F√úR DIE BEST√ÑTIGUNGS-VERZ√ñGERUNG
  const CONFIRM_BUTTON_DELAY_MS = 60;

  // SAP-Hintergrund An/Aus helper
  function showSAPBackground(show = true) {
    const sapBg = document.getElementById('sap-bg');
    const jspsychContainer = document.getElementById('jspsych-container');

    if (show) { 
      // === STIL F√úR GRID-TRIALS (MIT SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = '';
      document.body.style.background = "#f5f6f7";
      if (jspsychContainer) {
        jspsychContainer.style.top = '125px';
        jspsychContainer.style.height = 'calc(100vh - 125px)';
      }
    } else { 
      // === STIL F√úR TEXT-TRIALS (OHNE SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = 'none';
      document.body.style.background = "white";
      if (jspsychContainer) {
        // Wir setzen den Container auf volle Bildschirmh√∂he
        jspsychContainer.style.top = '0px';
        jspsychContainer.style.height = '100vh';
      }
    }
  }

  // ==== KONSTANTEN ====
  const appNames = [
      "Limo7", "Loru7", "HivoN", "HoruN", 
      "PikaX", "PoliX", "Pansi2", "Pexi2", 
      "MenoL", "MuniL", "Fexa5", "Fumi5",
      "Venni9", "Vabo9", "Vuma3", "Vezu3",
      "SuniX", "SokuX", "Samr7", "Seda7",
      "RafiQ", "RibuQ", "RapoM", "RenuM",
      "Keso2", "Kipu2", "KanoL", "KuraL", 
      "KariQ", "KesoQ"
    ];
  const symbols = [
    '‚ñ≤\uFE0E',  '‚ñ†\uFE0E',  '‚óè\uFE0E',  '‚óÜ\uFE0E',  '‚òÖ\uFE0E',  '‚úö\uFE0E', '‚òÄ\uFE0E', '‚òÅ\uFE0E', '‚ôû\uFE0E'
  ];

  // ==== JSPSYCH INIT ====
  const jsPsych = initJsPsych({
    display_element: 'jspsych-container',
    on_finish: function() {
        // Daten als CSV herunterladen
        jsPsych.data.get().localSave('csv', 'sap_app_task_data.csv', {
            exclude_columns: ['timeout', 'failed_images', 'failed_video', 'failed_audio']
        });

        // Optional: Eine "Danke"-Nachricht anzeigen, damit der Teilnehmer wei√ü, dass das Experiment beendet ist.
        document.getElementById('jspsych-container').innerHTML = `
            <div style="max-width: 900px; margin: 0 auto; text-align: center; padding-top: 100px;">
                <h2>Vielen Dank f√ºr Ihre Teilnahme!</h2>
                <p>Ihre Daten wurden automatisch gespeichert.</p>
                <p>Sie k√∂nnen das Fenstern nun schlie√üen.</p>
            </div>
        `;
        // Stellen Sie sicher, dass der SAP-Hintergrund f√ºr die Danke-Nachricht ausgeblendet ist
        showSAPBackground(false);
    }
  });

  // ==== BLOCKS UND PROBE-TYPEN DEFINITION ====
  const trialsPerBlock = 120; 

  function generateBlockConditions(numTrials) {
      const conditions = [];
      const targetPresentCount = numTrials / 2; // 60
      const targetAbsentCount = numTrials / 2;  // 60

      const probeDistribution = {
          'on-probe': 0.40, // 40%
          'off-probe': 0.40, // 40%
          'no-probe': 0.20  // 20%
      };

      const addConditions = (isTargetPresent, count) => {
          let currentCount = 0;
          let tempConditions = [];
          for (const probeType in probeDistribution) {
              let numType = Math.round(count * probeDistribution[probeType]);
              if (currentCount + numType > count) {
                  numType = count - currentCount;
              }
              for (let i = 0; i < numType; i++) {
                  tempConditions.push({
                      isTargetPresent: isTargetPresent,
                      probeType: probeType
                  });
              }
              currentCount += numType;
          }
          // Adjust for any remaining rounding errors after initial distribution
          while (currentCount < count) {
              tempConditions.push({ isTargetPresent: isTargetPresent, probeType: jsPsych.randomization.sampleWithoutReplacement(Object.keys(probeDistribution), 1)[0] });
              currentCount++;
          }
          while (currentCount > count) {
              const idxToRemove = tempConditions.findIndex(c => c.isTargetPresent === isTargetPresent);
              if (idxToRemove !== -1) {
                  tempConditions.splice(idxToRemove, 1);
              }
              currentCount--;
          }
          conditions.push(...tempConditions);
      };

      addConditions(true, targetPresentCount);
      addConditions(false, targetAbsentCount);

      return jsPsych.randomization.shuffle(conditions);
  }

  let block1Conditions = generateBlockConditions(trialsPerBlock);
  let block2Conditions = generateBlockConditions(trialsPerBlock);

  const preload = {
    type: jsPsychPreload,
    images: [],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true)
  };

  const startPage = {
    type: jsPsychHtmlButtonResponse,
    stimulus: `
      <div style="max-width: 900px; margin: 0 auto; text-align: left;">
        <h2>Willkommen zum Experiment</h2>
        <p>Das Experiment wird ungef√§hr 30 Minuten dauern. Bitte stellen Sie sicher, dass sie w√§hrend dieser Zeit nicht gest√∂rt werden.</p>
        <p>Es wird empfohlen, das Experiment an einem Laptop / Computer oder an einem Tablet mit angeschlossener Tastatur durchzuf√ºhren.</p>
        <p>In diesem Experiment sehen Sie Raster mit App-Kacheln. Zu Beginn jedes Blocks wird Ihnen eine Ziel-App gezeigt.</p>
        <p>Ihre Aufgabe ist es, die Ziel-App im nachfolgenden Raster so schnell wie m√∂glich zu entdecken und zu reagieren:</p>
        <ul style="margin: 20px 0 20px 20px; padding-left: 20px;">
            <li>Dr√ºcken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken.</li>
            <li>Dr√ºcken Sie die Taste <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass die Ziel-App nicht vorhanden ist.</li>
        </ul>
        <p>Anschlie√üend erscheint normalerweise ein Feld ‚ÄûBest√§tigen‚Äú, bei dem Sie mit der Taste <b>${KEY_TARGET_PRESENT.toUpperCase()} oder ${KEY_TARGET_ABSENT.toUpperCase()}</b> so schnell wie m√∂glich reagieren sollen. In einigen F√§llen erscheint das "Best√§tigen"-Feld jedoch nicht, und der Trial endet direkt nach Ihrer ersten Tastendruck. Bei diesen Trials wird das App-Raster noch f√ºr 3 Sekunden angezeigt, um Ihre Aufmerksamkeit zu √ºberpr√ºfen.</p>
        <p style="text-align: center; margin-top: 30px;">Wenn Sie bereit sind, klicken Sie auf ‚ÄûWeiter‚Äú, um zu beginnen.</p>
      </div>
    `,
    choices: ['Weiter'],
    css_classes: ['vertically-centered-content'],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true),
    data: { trial_stage: 'instruction', block_type: 'Einleitung' }
};

  function getFixationTrial(blockType = 'unknown') {
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<div style="display:flex; justify-content:center; align-items:center; width:100%; height:100%; font-size: 50px; color: black; background: transparent;">+</div>', // Zentriertes '+' auf transparentem Hintergrund
      choices: [],
      trial_duration: 1000, // 1000ms Fixation
      response_ends_trial: false, 
      on_load: () => showSAPBackground(true), // Sicherstellen, dass SAP Hintergrund angezeigt wird
      on_finish: () => showSAPBackground(true), // Sicherstellen, dass SAP Hintergrund sichtbar bleibt
      data: { trial_stage: 'fixation', block_type: blockType }
    };
  }

  function getShowTarget(targetApp, highlight, blockType) {
      return {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => `
          <div style="max-width:900px; margin:0 auto; text-align:center;">
            <p><b>Dies ist die Ziel-App f√ºr die n√§chsten Trials.</b><br>
            Merken Sie sich Name und Symbol!</p>
            <p> Es gibt w√§hrend der n√§chsten Trials kein Feedback f√ºr die richtige Aushwahl der Ziel-App oder "Best√§tigen" Button Position, ob Ihre Wahl richtig 
              oder falsch war wird aber dennoch vermerkt.</p>
            <div style="display:flex; justify-content:center;">
              <div class="app-box${highlight ? ' highlight-target' : ''}" style="width:9vw; display:inline-flex;">
                ${targetApp.name}<div class="symbol">${targetApp.symbol}</div>
              </div>
            </div>
            <p style="margin-top: 30px;"><b>Dr√ºcken Sie die Leertaste, um fortzufahren.</b></p>
          </div>`,
        choices: [' '],
        css_classes: ['vertically-centered-content'],
        on_load: () => showSAPBackground(false),
        on_finish: () => showSAPBackground(true),
        data: { trial_stage: 'show_target', target_app_name: targetApp.name, target_app_symbol: targetApp.symbol, block_type: blockType }
      };
    }

    function getInstructions(blockName, highlight, blockType) {
    const step2_instruction_present = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe immer <b>mit einem dunkelgrauen Rahmen markiert</b>.`
      : `Finden Sie die Ziel-App im Raster.`;
    const step2_instruction_absent = `Stellen Sie fest, ob die Ziel-App nicht vorhanden ist.`;

    const stimulus_html = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">${blockName}</h2>
        <p>In diesem Block sehen Sie in mehreren Durchg√§ngen ein Raster mit Apps. Ihre Aufgabe ist es, in jedem Durchgang die folgenden Schritte so schnell und genau wie m√∂glich auszuf√ºhren:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Pr√§gen Sie sich die <b>Ziel-App</b> ein, die Ihnen zu Beginn und bei einem Wechsel angezeigt wird.</li>
          <li style="margin-bottom: 15px;">${step2_instruction_present} Dr√ºcken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken.</li>
          <li style="margin-bottom: 15px;">${step2_instruction_absent} Dr√ºcken Sie die Taste <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass die Ziel-App nicht vorhanden ist.</li>
          <li style="margin-bottom: 15px;">Ein Feld mit "<b>Best√§tigen</b>" erscheint an einer zuf√§lligen Stelle. Reagieren Sie darauf ebenfalls so schnell wie m√∂glich mit der <b>Taste ${KEY_TARGET_PRESENT.toUpperCase()} oder ${KEY_TARGET_ABSENT.toUpperCase()}</b>. Manchmal wird das "Best√§tigen"-Feld jedoch nicht erscheinen. Bei diesen Trials wird das App-Raster noch f√ºr 3 Sekunden angezeigt, um Ihre Aufmerksamkeit zu √ºberpr√ºfen.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">Wenn Sie bereit sind, klicken Sie auf "Weiter".</p>
      </div>
    `;

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: stimulus_html,
      choices: ['Weiter'],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'block_instruction', block_name_display: blockName, block_type: blockType }
    };
  }

  function renderLayoutRandomGrid(apps, highlightTarget) {
  // Erzeuge 4x4 Positionen
  let positions = [];
  for (let row = 1; row <= 4; row++) {
    for (let col = 1; col <= 4; col++) {
      positions.push({ row, col });
    }
  }
  // shuffle positions
  for (let i = positions.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [positions[i], positions[j]] = [positions[j], positions[i]];
  }
  // benutze nur so viele Positionen wie Apps geliefert wurden (z.B. 8 oder 4)
  let usedPositions = positions.slice(0, apps.length);

  // baue HTML; die app-boxen behalten die vorhandenen CSS-Klassen
  let html = `<div class="app-grid">`;
  usedPositions.forEach((pos, idx) => {
    let app = apps[idx];
    let targetClass = (highlightTarget && app.isTarget) ? " highlight-target" : "";
    html += `<div id="app-${idx}" class="app-box${targetClass}" 
              style="grid-row: ${pos.row}; grid-column: ${pos.col};">
              ${app.name}<div class="symbol">${app.symbol}</div>
            </div>`;
  });
  html += "</div>";
  return html;
}

  const layoutRenderers = [renderLayoutRandomGrid];
  const layoutNames = ["RandomGrid4x6"];

  function getSearchTrial(apps, highlightTarget, blockLabel, probeType, blockType, isTargetPresent) {
    const randomIndex = Math.floor(Math.random() * layoutRenderers.length);
    const renderer = layoutRenderers[randomIndex];
    const layoutName = layoutNames[randomIndex];
    
    const currentTrialProbeType = probeType; 
    const expectedKey = isTargetPresent ? KEY_TARGET_PRESENT : KEY_TARGET_ABSENT;

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        let instructionText = isTargetPresent 
            ? `<b>Dr√ºcken Sie die Taste ${KEY_TARGET_PRESENT.toUpperCase()}, sobald Sie die Ziel-App entdeckt haben!</b>`
            : `<b>Dr√ºcken Sie die Taste ${KEY_TARGET_ABSENT.toUpperCase()}, sobald Sie festgestellt haben, dass die Ziel-App NICHT vorhanden ist!</b>`;

        let html = `<div class="app-container">` + renderer(apps, highlightTarget) + `</div>
        <div style="margin-top:2em; font-size:1.2vw; color:#333;">${instructionText}</div>`;
        return html;
      },
      choices: 'NO_KEYS', 
      data: { 
        trial_stage: 'search_task', 
        block_type: blockType, 
        original_block_label: blockLabel,
        is_target_highlighted: highlightTarget, 
        layout: layoutName,
        probe_type: currentTrialProbeType,
        is_target_present: isTargetPresent,
        expected_key_search: expectedKey 
      }, 
      on_load: (trial) => {
        showSAPBackground(true);
        window.currentGridApps = apps.map(x => ({...x}));
        window.gridPositions = [];
        document.querySelectorAll('.app-box').forEach((box,i) => {
          window.gridPositions.push({
            i: i,
            style: box.getAttribute('style')
          });
        });
        window.memoryCheckTargetIdx = apps.findIndex(a => a.isTarget); 

        window.appScreenStart = performance.now();
        window.appRects = apps.map((a, i) => {
          const el = document.getElementById('app-' + i).getBoundingClientRect();
          return {
            name: a.name,
            x: el.left,
            y: el.top,
            width: el.width,
            height: el.height,
            isTarget: a.isTarget
          }
        });

        let finished = false;
        const handler = (e) => {
          const pressedKey = e.key.toLowerCase();
          if (pressedKey === KEY_TARGET_PRESENT || pressedKey === KEY_TARGET_ABSENT) { 
            e.preventDefault(); 
            if (!finished) {
              finished = true;
              const rt_select = performance.now() - window.appScreenStart;
              
              const isResponseCorrect = (pressedKey === expectedKey);

              let appRect = null;
              if (isTargetPresent) { 
                  const targetRectIdx = apps.findIndex(a => a.isTarget);
                  if (targetRectIdx !== -1) {
                      let targetEl = document.getElementById('app-' + targetRectIdx);
                      if (targetEl) appRect = targetEl.getBoundingClientRect();
                  }
              }
              window.appPosition = appRect ? { x: appRect.left, y: appRect.top, width: appRect.width, height: appRect.height } : null;

              const searchPhaseData = {
                  rt_select: rt_select,
                  response_key_search: pressedKey, 
                  is_response_correct_search: isResponseCorrect, 
                  app1_position_x: window.appPosition ? window.appPosition.x : null,
                  app1_position_y: window.appPosition ? window.appPosition.y : null,
              };

              if (currentTrialProbeType === 'no-probe') {
                  setTimeout(() => { 
                      jsPsych.finishTrial({
                          ...searchPhaseData,
                          confirm_position_x: null, 
                          confirm_position_y: null, 
                          rt_confirm: null,         
                          response_key_confirm: null, 
                          probe_type: currentTrialProbeType,
                          confirm_tries: null       
                      });
                  }, 3000); 
              } else {
                  setTimeout(() => showConfirmButton((confirmData) => { 
                    const confirmPosition = window.confirmPosition; 
                    jsPsych.finishTrial({ 
                      ...searchPhaseData,
                      confirm_position_x: confirmPosition ? confirmPosition.x : null,
                      confirm_position_y: confirmPosition ? confirmPosition.y : null,
                      ...confirmData 
                    });
                  }, false, currentTrialProbeType), CONFIRM_BUTTON_DELAY_MS); 
              }
              document.removeEventListener('keydown', handler, true); 
            }
          }
        };
        document.addEventListener('keydown', handler, true);
      },
      on_unload: () => {
        document.onkeydown = null;
      }
    };
  }


  // ==== PRACTICE TRIAL ====
  const totalPracticeTrials = 3; 

  function createSinglePracticeTrial(highlight, trialNum, totalTrials, blockType, fixedTargetApp) {
  // √úbung: nur 4 sichtbare Apps (1 Target + 3 Distraktoren),
  // diese werden in einem 4x4 Grid gerendert, d.h. es gibt leere Zellen
  const tempDistractorPool = appNames.filter(name => name !== fixedTargetApp.name);
  const distractors = jsPsych.randomization.sampleWithoutReplacement(tempDistractorPool, 3); // 3 Distraktoren

  let practiceApps = distractors.map(name => ({
    name: name,
    symbol: symbols[Math.floor(Math.random() * symbols.length)],
    isTarget: false
  }));
  practiceApps.push({
    name: fixedTargetApp.name,
    symbol: fixedTargetApp.symbol,
    isTarget: true
  });

  // mische die 4 Apps
  practiceApps = jsPsych.randomization.shuffle(practiceApps);

  const expectedKey = KEY_TARGET_PRESENT;

  const practiceSearchTrial = {
    type: jsPsychHtmlButtonResponse,
    stimulus: () => {
      // Wir nutzen denselben renderer renderLayoutRandomGrid, der jetzt 4x4 Positionen zur Verf√ºgung hat.
      // Da wir nur 4 Apps √ºbergeben, erscheinen genau 4 Boxen in zuf√§lligen Zellen des 4x4 Grids.
      window.currentGridApps = practiceApps;
      window.memoryCheckTargetIdx = practiceApps.findIndex(a => a.isTarget);

      // Keine speziellen override-styles n√∂tig; aber falls du kleineres √úbungs-Grid willst, kannst du override-Styles setzen.
      // Wir geben einfach das Grid zur√ºck, der Renderer platziert die 4 Apps innerhalb des 4x4-Rasters.
      let html = `<div class="app-container">` + renderLayoutRandomGrid(practiceApps, highlight) + `</div>`;
      html += `<div style="margin-top:2em; font-size:1.2vw; color:#333;"><b>Dr√ºcken Sie die Taste ${KEY_TARGET_PRESENT.toUpperCase()}, sobald Sie die Ziel-App entdeckt haben!</b></div>`;
      return html;
    },
    choices: 'NO_KEYS',
    data: {
      trial_stage: 'search_task',
      block_type: blockType,
      original_block_label: `√úbungstrial ${trialNum}`,
      is_target_present: true
    },
    on_load: () => {
      showSAPBackground(true);
      // update rectangles usw. (wie zuvor)
      window.appRects = [];
      document.querySelectorAll('.app-box').forEach((box, i) => {
        const el = box.getBoundingClientRect();
        window.appRects.push({
          name: window.currentGridApps[i].name,
          x: el.left,
          y: el.top,
          width: el.width,
          height: el.height,
          isTarget: window.currentGridApps[i].isTarget
        });
      });
      window.appScreenStart = performance.now();

      let finished = false;
      const handler = (e) => {
        const pressedKey = e.key.toLowerCase();
        if (pressedKey === KEY_TARGET_PRESENT) {
          e.preventDefault();
          if (!finished) {
            finished = true;
            const rt_select = performance.now() - window.appScreenStart;
            const targetElement = document.querySelector(`.app-box[data-idx="${window.memoryCheckTargetIdx}"]`);
            if (targetElement) {
              let appRect = targetElement.getBoundingClientRect();
              window.appPosition = { x: appRect.left, y: appRect.top, width: appRect.width, height: appRect.height };
            }
            const searchPhaseData = {
              rt_select: rt_select,
              response_key_search: pressedKey,
              is_response_correct_search: true,
              app1_position_x: window.appPosition ? window.appPosition.x : null,
              app1_position_y: window.appPosition ? window.appPosition.y : null,
            };
            // in √úbungstrials weiterhin on-probe
            setTimeout(() => showConfirmButton((confirmData) => jsPsych.finishTrial({ ...searchPhaseData, ...confirmData }), true, 'on-probe'), CONFIRM_BUTTON_DELAY_MS);
            document.removeEventListener('keydown', handler, true);
          }
        }
      };
      document.addEventListener('keydown', handler, true);
    }
  };

  return [
    // Fixation vor √úbungs-Suchtrial behalten
    getFixationTrial(blockType),
    practiceSearchTrial
  ];
}

  function makePracticeBlock(highlight) {
    const step2_instruction = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe <b>mit einem dunkelgrauen Rahmen markiert</b>.`
      : `Finden Sie die Ziel-App im Raster.`;

    const stimulus_html = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">√úbungsrunde</h2>
        <p>Wir beginnen mit einer kurzen √úbungsrunde mit ${totalPracticeTrials} Durchg√§ngen, um den Ablauf kennenzulernen. Bitte f√ºhren Sie die folgenden Schritte so schnell und genau wie m√∂glich aus:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Pr√§gen Sie sich die <b>Ziel-App</b> ein, die Ihnen zu Beginn gezeigt wird.</li>
          <li style="margin-bottom: 15px;">${step2_instruction} Dr√ºcken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>.</li>
          <li style="margin-bottom: 15px;">Ein Feld mit "<b>Best√§tigen</b>" erscheint. Reagieren Sie darauf ebenfalls so schnell wie m√∂glich mit der <b>Taste ${KEY_TARGET_PRESENT.toUpperCase()} oder ${KEY_TARGET_ABSENT.toUpperCase()}</b>.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">In der √úbungsrunde ist die Ziel-App immer im Raster vorhanden und das "Best√§tigen"-Feld wird immer erscheinen.</p>
        <p style="text-align: center; margin-top: 10px;">Wenn Sie bereit sind, klicken Sie auf "Weiter".</p>
      </div>
    `;

    const practiceInstructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: stimulus_html,
      choices: ['Weiter'],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'practice_instruction', block_type: '√úbung' }
    };

    const practice_timeline = [practiceInstructions];

    const practiceTargetApp = {
        name: jsPsych.randomization.sampleWithoutReplacement(appNames, 1)[0],
        symbol: symbols[Math.floor(Math.random() * symbols.length)]
    };
    
    practice_timeline.push(getShowTarget(practiceTargetApp, highlight, '√úbung'));

    for (let i = 0; i < totalPracticeTrials; i++) {
        const single_trial_nodes = createSinglePracticeTrial(highlight, i + 1, totalPracticeTrials, '√úbung', practiceTargetApp);
        practice_timeline.push(...single_trial_nodes);
    }

    const endPractice = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="font-size: 20px; text-align: center; max-width: 800px; margin: 0 auto;">
          <p>Die √úbungsrunde ist beendet.</p>
          <p>Der Hauptblock beginnt jetzt.</p>
          <p style="margin-top: 30px;"><b>Dr√ºcken Sie die Leertaste, um fortzufahren.</b></p>
        </div>
      `,
      choices: [' '],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'practice_end', block_type: '√úbung' }
    };
    practice_timeline.push(endPractice);

    return practice_timeline;
  }

  const numTargetsPerExperiment = 12; 
  const allExperimentTargetNames = jsPsych.randomization.sampleWithoutReplacement(appNames, numTargetsPerExperiment);

  const globalDistractorPool = appNames.filter(name => !allExperimentTargetNames.includes(name));

  function makeBlockTrials(highlight, blockLabel, trialConditionsArr, blockOrderNumber) { 
    const block = [];
    
    const displayBlockName = `Block ${blockOrderNumber}`;
    block.push(getInstructions(displayBlockName, highlight, blockLabel)); 
    
    block.push(...makePracticeBlock(highlight));

    let targetsForThisBlockNames;
    if (blockOrderNumber === 1) {
        targetsForThisBlockNames = allExperimentTargetNames.slice(0, 4); 
    } else { 
        targetsForThisBlockNames = allExperimentTargetNames.slice(4, 8); 
    }
    
    const blockTargets = targetsForThisBlockNames.map(name => ({ 
        name: name, 
        symbol: symbols[Math.floor(Math.random() * symbols.length)] 
    }));

    let currentTargetIdx = 0;
    block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel)); 

    for (let i = 0; i < trialsPerBlock; i++) { 
      if (i > 0 && i % 20 === 0) { 
        currentTargetIdx = (currentTargetIdx + 1) % blockTargets.length; 
        block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel)); 
      }
      
      const currentCondition = trialConditionsArr[i]; 
      let currentTarget = blockTargets[currentTargetIdx]; 

      let gridAppsNames;
      const numAppsInGrid = 8; 

      if (currentCondition.isTargetPresent) {
          const availableDistractors = globalDistractorPool.filter(name => name !== currentTarget.name);
          gridAppsNames = jsPsych.randomization.sampleWithoutReplacement(availableDistractors, numAppsInGrid - 1);
          gridAppsNames.push(currentTarget.name); 
      } else {
          const availableDistractors = globalDistractorPool.filter(name => name !== currentTarget.name);
          gridAppsNames = jsPsych.randomization.sampleWithoutReplacement(availableDistractors, numAppsInGrid);
      }

      let gridApps = jsPsych.randomization.shuffle(gridAppsNames).map(name => ({
        name: name,
        symbol: (currentCondition.isTargetPresent && name === currentTarget.name) 
                  ? currentTarget.symbol 
                  : symbols[Math.floor(Math.random() * symbols.length)],
        isTarget: (currentCondition.isTargetPresent && name === currentTarget.name)
      }));

      block.push(getFixationTrial(blockLabel)); 
      block.push(getSearchTrial(
        gridApps,
        highlight,
        blockLabel,
        currentCondition.probeType, 
        blockLabel,
        currentCondition.isTargetPresent 
      ));
    }
    return block;
  }


  function getRectDistance(rect1, rect2) {
      const r1 = {x1: rect1.x, y1: rect1.y, x2: rect1.x + rect1.width, y2: rect1.y + rect1.height};
      const r2 = {x1: rect2.x, y1: rect2.y, x2: rect2.x + rect2.width, y2: rect2.y + rect2.height}; 
      const dx = Math.max(0, r1.x1 - r2.x2, r2.x1 - r1.x2);
      const dy = Math.max(0, r1.y1 - r2.y2, r2.y1 - r1.y2);
      return Math.sqrt(dx * dx + dy * dy);
  }

  function getOverlapArea(rect1, rect2) {
      const x_overlap = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x));
      const y_overlap = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
      return x_overlap * y_overlap;
  }


  const showConfirmButton = (callback, isPractice = false, probeType = null) => {
  if (probeType === 'no-probe') {
    callback({
      rt_confirm: null,
      response_key_confirm: null,
      probe_type: probeType,
      confirm_tries: 0,
      confirm_position_x: null,
      confirm_position_y: null
    });
    return;
  }

  const confirm = document.createElement('div');
  confirm.className = 'confirm-box';
  confirm.textContent = 'Best√§tigen';

  const paddingY = window.innerHeight * 0.05;
  const paddingX = window.innerWidth * 0.05;

  const minimumTopInPixels = 140;
  const topBoundary = Math.max(minimumTopInPixels, window.innerHeight * 0.10);
  const bottomBoundary = window.innerHeight - paddingY;
  const leftBoundary = paddingX;
  const rightBoundary = window.innerWidth - paddingX;

  // Tempor√§re Platzierung, um Gr√∂√üe zu messen
  confirm.style.position = 'absolute';
  confirm.style.left = '-1000px';
  confirm.style.top = '-1000px';
  document.body.appendChild(confirm);

  const buttonW = confirm.offsetWidth;
  const buttonH = confirm.offsetHeight;
  const buttonArea = buttonW * buttonH;

  // *** HIER IST DIE ANPASSUNG F√úR DIE GRENZE DES BEST√ÑTIGEN-BUTTONS ***
  // Vermeide die √§u√üerste rechte Bildschirmzone: 15% der Breite oder mindestens 100px
  const avoidRightPx = Math.max(100, Math.round(window.innerWidth * 0.15)); // 15% statt 12%
  let rightBoundaryUsed = rightBoundary - avoidRightPx;

  // Fallback, falls der m√∂gliche Bereich zu eng wird (z.B. wenn der Bildschirm sehr schmal ist)
  if (rightBoundaryUsed - leftBoundary - buttonW < 20) { // Mindestbreite von 20px f√ºr den Zufallsbereich
    rightBoundaryUsed = rightBoundary - buttonW; // Fallback: Nur die Breite des Buttons abziehen
  }
  // *** ENDE DER ANPASSUNG ***

  // probeType sicherstellen
  if (isPractice && !probeType) {
    probeType = Math.random() < 0.5 ? 'on-probe' : 'off-probe';
  } else if (!isPractice && !probeType) {
    console.error("showConfirmButton wurde ohne probeType im Haupt-Trial aufgerufen. Using fallback 'off-probe'.");
    probeType = 'off-probe';
  }

  let confirmX = leftBoundary; // Initialisierung
  let confirmY = topBoundary; // Initialisierung
  let tries = 0;
  let found = false;

  const rects = window.appRects || [];
  const nonTargetRects = rects.filter(r => !r.isTarget);
  const targetRect = rects.find(r => r.isTarget);

  while (tries < 1000 && !found) {
    // X innerhalb eingeschr√§nkter Grenzen w√§hlen
    const minX = leftBoundary;
    const maxX = Math.max(minX, rightBoundaryUsed - buttonW); // Stelle sicher, dass maxX nicht kleiner als minX ist
    if (maxX <= minX) {
      // Fallback: Wenn der eingeschr√§nkte Bereich zu klein ist, nutze den gesamten verf√ºgbaren Bereich
      confirmX = leftBoundary + Math.random() * (rightBoundary - leftBoundary - buttonW);
    } else {
      confirmX = minX + Math.random() * (maxX - minX);
    }
    // Y wie gehabt innerhalb der normalen Grenzen
    confirmY = topBoundary + Math.random() * (bottomBoundary - topBoundary - buttonH);

    const currentConfirmRect = { x: confirmX, y: confirmY, width: buttonW, height: buttonH };

    if (probeType === 'on-probe') {
      let hasSufficientOverlapWithNonTarget = false;
      for (const rect of nonTargetRects) {
        const overlap = getOverlapArea(currentConfirmRect, rect);
        if (overlap / buttonArea >= 0.75) {
          hasSufficientOverlapWithNonTarget = true;
          break;
        }
      }

      let overlapsTarget = false;
      if (targetRect) {
        const overlapTarget = getOverlapArea(currentConfirmRect, targetRect);
        if (overlapTarget > 0.001) overlapsTarget = true;
      }

      if (hasSufficientOverlapWithNonTarget && !overlapsTarget) found = true;
    } else {
      // off-probe: keine √úberlappung und nicht zu nah an Apps
      let anyOverlap = false;
      let tooCloseToApps = false;
      for (const rect of rects) {
        const overlap = getOverlapArea(currentConfirmRect, rect);
        if (overlap > 0.001) {
          anyOverlap = true;
          break;
        }
        const dist = getRectDistance(currentConfirmRect, rect);
        if (dist < window.innerWidth * 0.02) {
          tooCloseToApps = true;
          break;
        }
      }
      if (!anyOverlap && !tooCloseToApps) found = true;
    }
    tries++;
  }

  if (!found) {
    console.warn(`Konnte keine optimale Position f√ºr den 'Best√§tigen'-Button (${probeType}) nach ${tries} Versuchen finden. Platzierung k√∂nnte suboptimal sein.`);
  }

  confirm.style.left = `${confirmX}px`;
  confirm.style.top = `${confirmY}px`;

  const confirmRect = confirm.getBoundingClientRect();
  window.confirmPosition = { x: confirmRect.left, y: confirmRect.top };
  window.confirmAppearTime = performance.now();

  let finished = false;
  const handler = (e) => {
    const pressedKey = e.key.toLowerCase();
    if (pressedKey === KEY_TARGET_PRESENT || pressedKey === KEY_TARGET_ABSENT) {
      e.preventDefault();
      if (!finished) {
        finished = true;
        const rt_confirm = performance.now() - window.confirmAppearTime;
        const dataToReturn = {
          rt_confirm: rt_confirm,
          response_key_confirm: pressedKey,
          probe_type: probeType,
          confirm_tries: tries
        };
        confirm.remove();
        document.removeEventListener('keydown', handler, true);
        callback(dataToReturn);
      }
    }
  };
  document.addEventListener('keydown', handler, true);
};


  // === Timeline ===
  const block_definitions = [
    { highlight: false, label: "Test-Block", conditions: block1Conditions }, 
    { highlight: true, label: "Baseline-Block", conditions: block2Conditions } 
  ];

  const randomized_blocks = jsPsych.randomization.shuffle(block_definitions);

  const firstBlock = makeBlockTrials(
    randomized_blocks[0].highlight,
    randomized_blocks[0].label,
    randomized_blocks[0].conditions, 
    1 
  );

  const secondBlock = makeBlockTrials(
    randomized_blocks[1].highlight,
    randomized_blocks[1].label,
    randomized_blocks[1].conditions, 
    2 
  );
  
  const timeline = [preload, startPage, ...firstBlock, ...secondBlock];

  jsPsych.run(timeline);
</script>
</body>
</html>