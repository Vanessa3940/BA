<!DOCTYPE html>
<html>
<head>
    <title>SAP App Task</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.1"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" />
    <style>
      /* Diese Regel wird nur auf Trials angewendet, denen wir die Klasse'vertically-centered-content'
      im JavaScript-Code geben. */
        .jspsych-trial.vertically-centered-content .jspsych-display-element {
            display: flex;
            flex-direction: column;
            justify-content: center; /* Zentriert den Inhalt vertikal */
            height: 100%;            /* F√ºllt den gesamten Platz aus */
        }
  
        /* Diese Regel verhindert, dass unser App-Grid von der Zentrierung betroffen ist,
          und behebt das Problem der Rechtsverschiebung. */
        .jspsych-display-element {
            width: 100%;
        }
  
        /* Passt die Breite der Textbl√∂cke NUR auf den zentrierten Seiten an */
        .jspsych-trial.vertically-centered-content .jspsych-display-element > div {
          max-width: 900px; /* Beh√§lt die maximale Breite f√ºr Lesbarkeit bei */
          width: 100%;
          text-align: left; /* Stellt sicher, dass der Text linksb√ºndig bleibt */
        }
        
        html, body {
          width: 100vw;
          height: calc(var(--vh, 1vh) * 100);
          max-height: calc(var(--vh, 1vh) * 100);
          overflow: hidden !important;
          margin: 0;
          padding: 0;
          font-family: Arial, sans-serif;
          background: #f5f6f7;
        }
        .sap-header {
          position: fixed;
          top: 0; left: 0; width: 100vw; z-index: 0;
          background: #fff;
          height: 82px;
          box-shadow: 0 2px 3px 0 rgba(0,0,0,0.05), 0 1px 0px 0 #e2e5e7;
          border-bottom: 1.5px solid #e2e5e7;
          display: flex;
          align-items: center;
          padding: 0 30px;
        }
        .sap-logo {
          height: 35px;
          width: 68px;
          margin-right: 24px;
        }
        .header-menu {
          display: flex;
          align-items: center;
          gap: 18px;
        }
        .menu-item {
          color: #222;
          font-size: 17px;
          font-weight: bold;
          margin-right: 18px;
          cursor: pointer;
          padding: 7px 10px;
          border-radius: 6px;
        }
        .menu-item.active {
          color: #186FDB;
          border-bottom: 2px solid #186FDB;
        }
        .header-right {
          margin-left: auto;
          display: flex;
          gap: 18px;
          align-items: center;
        }
        .header-ico {
          font-size: 20px;
          color: #444;
          background: #f8f8f8;
          border-radius: 50%;
          padding: 5px;
          width: 32px;
          height: 32px;
          display: flex;
          align-items: center;
          justify-content: center;
          margin-right: 2px;
        }
        .header-avatar {
          width: 35px;
          height: 35px;
          background: #dbeafe;
          color: #2981ea;
          border-radius: 999px;
          display: flex;
          align-items: center; justify-content: center;
          font-size: 18px; font-weight: bold;
          margin-left: 10px;
        }
        .sap-overview {
          position: fixed;
          top: 90px; left: 2.3vw; z-index: 0;
          font-size: 2.0vw; font-weight: bold; color: #262f38;
          text-shadow: 0 1px 0 #fff;
          letter-spacing: 0;
          margin-bottom: 16px;
        }
        .sap-grey-bg {
          position: fixed;
          top: 125px;
          left: 0;
          width: 100vw;
          height: calc(100vh - 125px);
          background: linear-gradient(180deg,#F5F7F8 80%,#EDF0F1 100%);
          z-index: 0;
        }
        #jspsych-container { /* Nur jspsych-container, nicht alle .app-container */
          width: 100vw;
          overflow: hidden;
          position: relative;
          margin: 0;
          padding: 0;
          box-sizing: border-box;
          height: calc((var(--vh, 1vh) * 100) - 125px - 2.5vw); 
        }
  
        /* Globale app-container Regeln - f√ºr Haupttrials relevant */
        .app-container {
          width: 100vw;
          height: calc((var(--vh, 1vh) * 100) - 125px - 2.5vw);
          overflow: hidden;
          position: relative;
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
  
        .app-grid {
          display: grid;
          grid-template-columns: repeat(6, 1fr);
          grid-template-rows: repeat(4, 1fr);
          width: 100%;
          height: 100%;
          gap: 2.5vw;
          padding: 1vw 2.5vw; 
          box-sizing: border-box;
          justify-items: center;
          align-items: center;
        }
  
        .app-box {
          aspect-ratio: 1 / 1;
          width: 100%;
          max-width: 9vw;
          max-height: 100%;
          background-color: white;
          border: 2px solid #ccc;
          border-radius: 1vw;
          box-shadow: 0.2vw 0.2vw 0.5vw rgba(0, 0, 0, 0.2);
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          box-sizing: border-box;
          user-select: none;
          text-align: center;
          font-size: 1.6vw;
          transition: border 0.2s;
          z-index: 10;
          min-width: 0;
          min-height: 0;
        }
  
        .empty-app {
          background: #e4e8ec !important;
          border: 2px solid #bbb;
          cursor: pointer;
          transition: background 0.2s;
        }
        .app-box.empty-app:hover {
          background: #cdd8df !important;
        }
        .symbol {
          font-size: 2vw;
          color: #555;
        }
        .fixation-screen {
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          background-color: white;
          font-size: 5vw;
        }
        .confirm-box {
          position: absolute;
          background-color: #fff;
          color: #1976d2;
          padding: 0.2vw 0.7vw;
          border-radius: 8px;
          font-size: 1vw;
          cursor: pointer;
          z-index: 20;
          border: 2px solid  #1976d2;
          font-weight: 500;
          box-shadow: none;
          font-family: inherit;
          width: 4vw;
          height: 2.2vw;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .highlight-target {
          border: 4px solid #888 !important;
          box-shadow: 0 0 12px #bbb !important;
        }
        /* NEUE CSS F√úR FEEDBACK */
        .correct-feedback-highlight-green {
          border: 4px solid #4CAF50 !important; /* Gr√ºner Rand */
          box-shadow: 0 0 15px rgba(76, 175, 80, 0.7) !important; /* Gr√ºner Glanz */
        }
        .feedback-text-overlay {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 3vw; 
          font-weight: bold;
          padding: 0.5vw 1vw;
          border-radius: 8px;
          z-index: 100; /* Sicherstellen, dass es √ºber allem anderen liegt */
          text-align: center;
          pointer-events: none; /* Sorgt daf√ºr, dass Klicks durchgehen */
          min-width: 100px; /* Mindestbreite, damit der Text gut sichtbar ist */
        }
        .feedback-text-overlay.correct {
          color: #4CAF50; /* Gr√ºner Text */
          background-color: rgba(232, 245, 233, 0.9); /* Leicht gr√ºner, halbtransparenter Hintergrund */
        }
        .feedback-text-overlay.incorrect {
          color: #F44336; /* Roter Text */
          background-color: rgba(255, 235, 238, 0.9); /* Leicht roter, halbtransparenter Hintergrund */
        }
        /* NEUE CSS F√úR DENKBLASEN-HIGHLIGHT */
        .thought-bubble.highlight-red {
            border: 4px solid #F44336 !important; /* Roter Rand, 4px f√ºr mehr Sichtbarkeit */
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.7) !important; /* Roter Glanz */
        }
        .thought-bubble.highlight-red::before {
            border-color: transparent #F44336 transparent transparent; /* Roten Pfeilrand anpassen */
        }
        /* Der innere Pfeil muss nicht angepasst werden, da er den Hintergrund der Blase hat */
  
        /* NEUE CSS F√úR PRACTICE-BEREICH UND DENKBLASE */
        .practice-area {
          display: flex;
          justify-content: center; /* Zentriert den gesamten Bereich */
          align-items: flex-start; /* Oben ausrichten */
          width: 100%;
          /* Wichtig: Diese H√∂he muss den gesamten verf√ºgbaren Platz ausf√ºllen */
          height: 100%; /* Lasst practice-area die volle H√∂he des jspsych-containers nutzen */
          box-sizing: border-box;
          padding: 20px; /* Etwas Abstand um den Bereich */
          overflow: hidden; /* Verhindert internes Scrollen */
          min-height: 0; /* Erm√∂glicht der practice-area, bei Bedarf zu schrumpfen */
        }
  
        /* Anpassung des app-container innerhalb des practice-area */
        /* Wichtig: Dies √ºberschreibt die globale .app-container Regel nur f√ºr diesen Kontext */
        .practice-area .app-container {
          width: 70%; /* Platz f√ºr die Denkblase lassen */
          height: auto; /* Muss auto sein, damit es sich an den Inhalt anpasst */
          min-height: 0; /* Erm√∂glicht dem app-container, bei Bedarf zu schrumpfen */
          position: relative; 
          flex-shrink: 0; /* Verhindert Schrumpfung (Standardverhalten im Zeilen-Layout) */
          margin-right: 2vw; /* Abstand zwischen Grid und Denkblase */
          display: flex; /* Flex-Container f√ºr app-grid */
          flex-direction: column; /* Stapelt das app-grid vertikal */
          justify-content: center; /* Zentriert das app-grid vertikal */
          align-items: center; /* Zentriert das app-grid horizontal */
        }
        /* Spezifische Regel f√ºr das app-grid innerhalb der practice-area */
        .practice-area .app-container .app-grid {
            flex-grow: 1; /* Erm√∂glicht dem Grid, verf√ºgbaren Platz zu nutzen */
            min-height: 0; /* Erm√∂glicht dem Grid, bei Bedarf zu schrumpfen */
        }
  
  
        .thought-bubble {
          flex-grow: 1; /* Nimmt den restlichen Platz ein */
          max-width: 25%; /* Begrenzt die maximale Breite */
          background-color: #f8f8f8; /* Heller Hintergrund */
          border: 1px solid #ddd;
          border-radius: 12px;
          padding: 1.2vw 1.5vw; /* Responsives Padding */
          box-shadow: 0 2px 5px rgba(0,0,0,0.08);
          font-size: 1.1vw; /* Responsive Schriftgr√∂√üe */
          line-height: 1.5;
          color: #333;
          z-index: 50;
          box-sizing: border-box;
          text-align: left;
          position: relative; /* F√ºr den Pfeil */
          transition: border 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* √úbergang f√ºr Gl√ºhen */
          min-height: 0; /* Erm√∂glicht der Denkblase, bei Bedarf zu schrumpfen */
        }
  
        /* Pfeil, der nach links zum Grid zeigt */
        .thought-bubble::before {
          content: "";
          position: absolute;
          top: 20%; /* Vertikale Position des Pfeils anpassen */
          left: -18px; /* Nach links positionieren */
          border-width: 10px;
          border-style: solid;
          border-color: transparent #ddd transparent transparent;
        }
        .thought-bubble::after { /* Innerer Pfeil f√ºr den Hintergrund */
          content: "";
          position: absolute;
          top: 20%;
          left: -16px;
          border-width: 9px;
          border-style: solid;
          border-color: transparent #f8f8f8 transparent transparent;
        }
  
        /* Media Query f√ºr kleinere Bildschirme / Tablets im Hochformat */
        /* Wichtig: Diese Regeln gelten nur, wenn die Bildschirmbreite <= 1024px ist */
        @media (max-width: 1024px) { 
          /* --- Allgemeine mobile Anpassungen (k√∂nnen auch Haupttrials betreffen) --- */
          .sap-overview { font-size: 26px; }
          .confirm-box { font-size: 13px; width: 60px; height: 40px; }
          .feedback-text-overlay { font-size: 26px; }
  
          /* --- Spezifische Anpassungen F√úR DIE PRACTICE AREA auf kleineren Bildschirmen --- */
          .practice-area {
            flex-direction: column; /* Vertikal stapeln */
            align-items: center;    /* Elemente zentrieren */
            padding: 8px 10px;      /* Reduziertes Padding f√ºr mehr Platz */
            justify-content: flex-start; /* Elemente eher oben ausrichten */
            height: auto;           /* L√§sst die H√∂he durch den Inhalt bestimmen */
          }
          
          /* App-Container innerhalb der Practice Area */
          .practice-area .app-container {
            width: 95%;             /* Breiteres App-Grid */
            height: auto;           /* Automatische H√∂he */
            margin-right: 0;
            margin-bottom: 8px;     /* Abstand zwischen Grid und Denkblase reduzieren */
            flex-grow: 1;           /* Erlaubt dem App-Container, den Raum zu nutzen */
            flex-shrink: 1;         /* Erlaubt dem App-Container, bei Bedarf zu schrumpfen */
          }
  
          /* App-Grid innerhalb des Practice App-Containers */
          .practice-area .app-container .app-grid {
            gap: 1.5vw;             /* Reduzierter Abstand zwischen App-Boxen */
            padding: 0.5vw;         /* Reduzierter Innenabstand des Grids */
          }
  
          /* App-Boxen innerhalb des Practice App-Containers */
          .practice-area .app-container .app-box {
            max-width: 80px;        /* Feste maximale Breite f√ºr kompaktere Apps */
            font-size: 14px;        /* Kleinere Schriftgr√∂√üe f√ºr App-Namen */
            padding: 2px;           /* Inneres Padding der Box reduzieren */
          }
          .practice-area .app-container .app-box .symbol {
            font-size: 18px;        /* Symbol auch kleiner */
          }
  
          /* Denkblase innerhalb der Practice Area */
          .thought-bubble {
            max-width: 95%;         /* Breitere Denkblase */
            font-size: 14px;        /* Schriftgr√∂√üe reduzieren */
            padding: 8px;           /* Padding reduzieren */
            margin-bottom: 5px;     /* Abstand unter der Denkblase reduzieren */
            flex-grow: 0;           /* Denkblase soll nicht unn√∂tig wachsen */
            flex-shrink: 1;         /* Denkblase soll bei Bedarf schrumpfen */
          }
          .thought-bubble::before, .thought-bubble::after {
            display: none;          /* Pfeil auf kleinen Bildschirmen ausblenden */
          }
        }
  
        /* Zus√§tzliche Media Query f√ºr SEHR kleine Bildschirme (z.B. Smartphones im Hochformat) */
        /* Wichtig: Diese Regeln gelten nur, wenn die Bildschirmbreite <= 704px ist */
        @media (max-width: 704px) {
          /* --- Allgemeine sehr mobile Anpassungen (k√∂nnen auch Haupttrials betreffen) --- */
          .sap-overview { font-size: 22px; }
          .confirm-box { font-size: 10px; width: 50px; height: 30px; }
          .feedback-text-overlay { font-size: 22px; }
  
          /* --- Spezifische Anpassungen F√úR DIE PRACTICE AREA auf sehr kleinen Bildschirmen --- */
          .practice-area {
              padding: 5px 8px; /* Noch weiter reduziertes Padding */
          }
          .practice-area .app-container {
              margin-bottom: 5px; /* Noch weiter reduzierter Abstand */
          }
          .practice-area .app-container .app-grid {
              gap: 1vw; /* Noch kleinerer Abstand zwischen App-Boxen */
              padding: 0.1vw; /* Minimales Padding */
          }
          .practice-area .app-container .app-box {
              max-width: 65px; /* Noch kleinere App-Boxen */
              font-size: 12px; /* Kleinere Schriftgr√∂√üe */
              padding: 1px;    /* Minimales Padding */
          }
          .practice-area .app-container .app-box .symbol {
              font-size: 15px; /* Symbol auch kleiner */
          }
          .thought-bubble {
              font-size: 12px; /* Kleinere Schriftgr√∂√üe */
              padding: 5px;    /* Reduziertes Padding */
              margin-bottom: 2px; /* Minimaler Abstand */
          }
        }
  
        /* Standard-Anleitungstext unter dem Grid ausblenden, wenn die Denkblase angezeigt wird */
        .practice-area .app-container + div[style*="margin-top:2em"] {
            display: none; 
        }
        /* Die vorherige Regel ist jetzt nicht mehr notwendig, da wir das Plugin selbst √§ndern. */
        /* .jspsych-trial:has(.practice-area) > .jspsych-prompt {
            display: none !important;
        } */
      </style>

  <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.1"></script> 


</head>
<body>
<div id="sap-bg">
  <div class="sap-header">
    <svg class="sap-logo" width="68" height="35" viewBox="0 0 68 35" xmlns="http://www.w3.org/2000/svg">
      <rect width="68" height="35" fill="#008FD3" />
    </svg>
    <span style="font-size:23px; margin-right:14px; cursor:pointer;">‚ò∞</span>
    <div class="header-menu">
      <span class="menu-item">Lunivox</span>
      <span class="menu-item">Trenola</span>
      <span class="menu-item active">Seraquix <span style="font-size:13px;">‚ñº</span></span>
    </div>
    <div class="header-right">
      <span class="header-ico">üîç</span>
      <span class="header-ico">üìç</span>
      <span class="header-ico">üéß</span>
      <span class="header-ico">‚ùì</span>
      <span class="header-ico">üîî</span>
      <span class="header-avatar">VM</span>
    </div>
  </div>
  <div class="sap-overview">Equao</div>
  <div class="sap-grey-bg"></div>
</div>
<div id="jspsych-container" style="position:absolute;top:125px;left:0;width:100vw;z-index:10;"></div>
<script>
  // Erg√§nzungen gegen Scrollen/Window-Resizing
  window.addEventListener('scroll', function() { window.scrollTo(0,0); });
  document.body.style.overflow = 'hidden';
  document.documentElement.style.overflow = 'hidden';
</script>
<script>
  // NEU: JavaScript zum Berechnen und Setzen der --vh CSS-Variable
  function setVhProperty() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  // Setzen beim Laden und bei Gr√∂√üen√§nderung (z.B. Orientierungswechsel auf Tablets)
  setVhProperty();
  window.addEventListener('resize', setVhProperty);

  

  // --- NEU HINZUF√úGEN: Globaler Event Listener, um das Scrollen mit der Leertaste zu verhindern ---
  document.addEventListener('keydown', function(e) {
    // Pr√ºft, ob die gedr√ºckte Taste die Leertaste ist (' ')
    if (e.key === ' ') {
      // Pr√ºft, ob das aktuell fokussierte Element KEIN Eingabefeld (input oder textarea) ist.
      // Das ist wichtig, damit die Leertaste in einem Textfeld im Experiment weiterhin funktioniert.
      const focusedElement = document.activeElement;
      const isInput = focusedElement.tagName === 'INPUT' || focusedElement.tagName === 'TEXTAREA';

      // Wenn die Leertaste gedr√ºckt wird und kein Eingabefeld fokussiert ist,
      // verhindern wir das Standardverhalten des Browsers (Scrollen).
      if (!isInput) {
        e.preventDefault();
      }
    }
  }, true); // 'true' hier bedeutet, dass der Event-Handler in der Capture-Phase ausgef√ºhrt wird,
            // also fr√ºhzeitig, bevor der Browser sein Standardverhalten ausf√ºhrt.

  



  // ==== KONSTANTEN F√úR REAKTIONSTASTEN ====
  const KEY_TARGET_PRESENT = 'j';
  const KEY_TARGET_ABSENT = 'f';
  // KEY_CONFIRM kann nun entweder 'j' oder 'f' sein, daher entfernen wir die Konstante und pr√ºfen dynamisch
  // const KEY_CONFIRM = 'j'; 

  // NEUE KONSTANTE F√úR DIE BEST√ÑTIGUNGS-VERZ√ñGERUNG
  const CONFIRM_BUTTON_DELAY_MS = 60;
  // NEUE KONSTANTE F√úR FEEDBACK-DAUER IN √úBUNGSRUNDEN
  const FEEDBACK_DURATION_MS = 700; 
  // NEUE KONSTANTE F√úR L√ÑNGERES FEEDBACK BEI FEHLERN IM NO-PROBE TRIAL DER √úBUNG
  const NO_PROBE_ERROR_FEEDBACK_DURATION_MS = 2000;


  // SAP-Hintergrund An/Aus helper
  function showSAPBackground(show = true) {
    const sapBg = document.getElementById('sap-bg');
    const jspsychContainer = document.getElementById('jspsych-container');

    if (show) { 
      // === STIL F√úR GRID-TRIALS (MIT SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = '';
      document.body.style.background = "#f5f6f7";
      if (jspsychContainer) {
        jspsychContainer.style.top = '125px';
        // NEU: Verwendet --vh Variable
        jspsychContainer.style.height = `calc((var(--vh, 1vh) * 100) - 125px - 2.5vw)`;
      }
    } else { 
      // === STIL F√úR TEXT-TRIALS (OHNE SAP-HINTERGRUND) ===
      if (sapBg) sapBg.style.display = 'none';
      document.body.style.background = "white";
      if (jspsychContainer) {
        // Wir setzen den Container auf volle Bildschirmh√∂he
        jspsychContainer.style.top = '0px';
        // NEU: Verwendet --vh Variable
        jspsychContainer.style.height = `calc(var(--vh, 1vh) * 100)`;
      }
    }
  }

  // ==== KONSTANTEN ====
  const appNames = [
      "Limo7", "Loru7", "HivoN", "HoruN", 
      "PikaX", "PoliX", "Pansi2", "Pexi2", 
      "MenoL", "MuniL", "Fexa5", "Fumi5",
      "Venni9", "Vabo9", "Vuma3", "Vezu3",
      "SuniX", "SokuX", "Samr7", "Seda7",
      "RafiQ", "RibuQ", "RapoM", "RenuM",
      "Keso2", "Kipu2", "KanoL", "KuraL", 
      "KariQ", "KesoQ"
    ];
  const symbols = [
    '‚ñ≤\uFE0E',  '‚ñ†\uFE0E',  '‚óè\uFE0E',  '‚óÜ\uFE0E',  '‚òÖ\uFE0E',  '‚úö\uFE0E', '‚òÄ\uFE0E', '‚òÅ\uFE0E', '‚ôû\uFE0E'
  ];

  // ==== JSPSYCH INIT ====
  const jsPsych = initJsPsych({
    display_element: 'jspsych-container',
    on_finish: function() {
        // 1. Sammle alle Trial-Objekte, die von jsPsych erfasst wurden.
        let all_trials_raw = jsPsych.data.get();
        
        // 2. Filter und mappe die Daten, um nur die 'data'-Eigenschaft der relevanten Trials zu erhalten.
        //    - Nur Trials, die ein 'data'-Objekt haben.
        //    - Nur Trials, deren 'block_num' definiert ist und nicht -1 ist (da -1 f√ºr irrelevante Trials wie Preload, Anweisungen verwendet wird).
        //    - Korrektur der 'Smart Quotes' zu geraden einfachen Anf√ºhrungszeichen.
        let data_to_send = all_trials_raw.trials.map(trial => ({
            b_t: trial.block_type ?? null,
            block_num: trial.block_num ?? null,
            rt_select: trial.rt_select != null ? Math.round(trial.rt_select) : null,
            target_present: trial.is_target_present ?? null,
            correct_response: trial.is_response_correct_search ?? null,
            probe_type: trial.probe_type ?? trial.probe_type_practice ?? null,
            rt_confirm: trial.rt_confirm != null ? Math.round(trial.rt_confirm) : null,
            key_no_probe: trial.accidental_keypress_no_probe ?? null

          })).filter(trial => trial.block_num == 0 || trial.block_num == 1)
        ;

          

        // Korrektur der 'Smart Quotes' im console.log
        console.log('data_to_send (anzahl):', data_to_send.length, data_to_send.slice(0,3));

        // Zeige die "Vielen Dank"-Nachricht an
        document.getElementById('jspsych-container').innerHTML = `
            <div style="max-width: 900px; margin: 0 auto; text-align: center; padding-top: 100px;">
                <h2>Vielen Dank f√ºr Ihre Teilnahme!</h2>
                <p>Ihre Daten wurden erfolgreich gespeichert.</p>
                <p>Sie k√∂nnen das Fenster nun schlie√üen.</p>
            </div>
        `;
        showSAPBackground(false); // Sicherstellen, dass der Hintergrund f√ºr die Danke-Nachricht ausgeblendet ist

        // Sende die gesammelten Daten als JSON-String an das Elternfenster (SoSci Survey)
        // Der zweite Parameter '*' bedeutet, dass die Nachricht an jedes Fenster gesendet werden kann.
        // Dies ist in Umfragekontexten oft akzeptabel.
        window.parent.postMessage(JSON.stringify(data_to_send), '*');
    }
  });

  // ==== BLOCKS UND PROBE-TYPEN DEFINITION ====
  const trialsPerBlock = 4; 

  function generateBlockConditions(numTrials) {
      const conditions = [];
      const targetPresentCount = numTrials / 2; // 60
      const targetAbsentCount = numTrials / 2;  // 60

      const probeDistribution = {
          'on-probe': 0.40, // 40%
          'off-probe': 0.40, // 40%
          'no-probe': 0.20  // 20%
      };

      const addConditions = (isTargetPresent, count) => {
          let currentCount = 0;
          let tempConditions = [];
          for (const probeType in probeDistribution) {
              let numType = Math.round(count * probeDistribution[probeType]);
              if (currentCount + numType > count) {
                  numType = count - currentCount;
              }
              for (let i = 0; i < numType; i++) {
                  tempConditions.push({
                      isTargetPresent: isTargetPresent,
                      probeType: probeType
                  });
              }
              currentCount += numType;
          }
          // Adjust for any remaining rounding errors after initial distribution
          while (currentCount < count) {
              tempConditions.push({ isTargetPresent: isTargetPresent, probeType: jsPsych.randomization.sampleWithoutReplacement(Object.keys(probeDistribution), 1)[0] });
              currentCount++;
          }
          while (currentCount > count) {
              const idxToRemove = tempConditions.findIndex(c => c.isTargetPresent === isTargetPresent);
              if (idxToRemove !== -1) {
                  tempConditions.splice(idxToRemove, 1);
              }
              currentCount--;
          }
          conditions.push(...tempConditions);
      };

      addConditions(true, targetPresentCount);
      addConditions(false, targetAbsentCount);

      return jsPsych.randomization.shuffle(conditions);
  }

  let block1Conditions = generateBlockConditions(trialsPerBlock);
  let block2Conditions = generateBlockConditions(trialsPerBlock);

  const preload = {
    type: jsPsychPreload,
    images: [],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true)
  };

  const startPage = {
    type: jsPsychHtmlButtonResponse,
    stimulus: `
      <div style="max-width: 900px; margin: 0 auto; text-align: left;">
        <h2>Willkommen zum Experiment</h2>
        <p>Das Experiment wird ungef√§hr <b>30 Minuten</b> dauern. Bitte stellen Sie sicher, dass sie w√§hrend dieser Zeit nicht gest√∂rt werden.</p>
        <p>Das Experiment sollte an einem <b>Laptop / Computer oder an einem Tablet mit angeschlossener Tastatur</b< durchgef√ºhrt werden, 
          weil man im Laufe des Experiments mit verschiedenen Tasten auf Stimuli reagieren muss.
          F√ºr einen optimalen Ablauf sollten Sie au√üerdem sicherstellen, dass ihr Browser-Fenster sich im <b>Vollbildmodus</b> befindet.</p>
        <p>In diesem Experiment geht es darum, bestimmte Ziel-Apps unter anderen Apps zu finden und anschlie√üend die Suche zu best√§tigen.</p>
        <p>Sie k√∂nnen das Experiment jederzeit unterbrechen, es wird allerdings auch w√§hrend des Experiments
          immer wieder M√∂glichkeiten geben, kleine Pausen einzulegen.</p>
        <p style="text-align: center; margin-top: 30px;">Klicken Sie auf "Experiment starten", um zu beginnen.</p>
      </div>
    `,
    choices: ['Experiment starten'],
    css_classes: ['vertically-centered-content'],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true),
    data: { trial_stage: 'instruction', block_type: 'Einleitung' }
};

  function getFixationTrial(blockType = 'unknown') {
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<div style="display:flex; justify-content:center; align-items:center; width:100%; height:100%; font-size: 50px; color: black; background: transparent;">+</div>', // Zentriertes '+' auf transparentem Hintergrund
      choices: [],
      trial_duration: 1000, // 1000ms Fixation
      response_ends_trial: false, 
      on_load: () => showSAPBackground(true), // Sicherstellen, dass SAP Hintergrund angezeigt wird
      on_finish: () => showSAPBackground(true), // Sicherstellen, dass SAP Hintergrund sichtbar bleibt
      data: { trial_stage: 'fixation', block_type: blockType }
    };
  }

  function getShowTarget(targetApp, highlight, blockType) {
      return {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: () => `
          <div style="max-width:900px; margin:0 auto; text-align:center;">
            <p><b>Dies ist die Ziel-App f√ºr die n√§chsten Trials.</b><br>
            Merken Sie sich Name und Symbol!</p>
            <div style="display:flex; justify-content:center;">
              <div class="app-box${highlight ? ' highlight-target' : ''}" style="width:9vw; display:inline-flex;">
                ${targetApp.name}<div class="symbol">${targetApp.symbol}</div>
              </div>
            </div>
            <p style="margin-top: 30px;">Dr√ºcken Sie die <b>Leertaste</b>, um fortzufahren.</p> <!-- GE√ÑNDERT: Nur Leertaste als Eingabe -->
          </div>`,
          choices: [' '], // GE√ÑNDERT: Nur Leertaste als Eingabe
        css_classes: ['vertically-centered-content'],
        on_load: () => showSAPBackground(false),
        on_finish: () => showSAPBackground(true),
        data: { trial_stage: 'show_target', target_app_name: targetApp.name, target_app_symbol: targetApp.symbol, block_type: blockType }
      };
    }

    function getInstructions(blockName, highlight, blockType) {
    const step2_instruction_present = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe immer <b>mit einem dunkelgrauen Rahmen markiert</b>.`
      : `Finden Sie die Ziel-App im Raster.`;
    const step2_instruction_absent = `Stellen Sie fest, ob die Ziel-App √ºberhaupt vorhanden ist.`;

    const stimulus_html = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">${blockName}</h2>
        <p>Ihre Aufgabe ist es, in jedem Durchgang so schnell und genau wie m√∂glich zu reagieren:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Merken Sie sich die aktuelle <b>Ziel-App</b>.</li>
          <li style="margin-bottom: 15px;">Fixieren Sie das schwarze Kreuz zu Beginn jedes Trials.</li>
          <li style="margin-bottom: 15px;">Suchen Sie die Ziel-App im Raster. Dr√ºcken Sie die <b>Taste J</b>, 
            wenn Sie die Ziel-App <b>finden</b>. 
          <li style="margin-bottom: 15px;">Dr√ºcken sie die <b>Taste F</b>, wenn Sie feststellen, dass die Ziel-App <b>nicht vorhanden</b> ist.
          <li style="margin-bottom: 15px;">Fixieren Sie das schwarze Kreuz zu Beginn jedes Trials.</li>
          <li style="margin-bottom: 15px;">Falls das Feld "<b>Best√§tigen</b>" erscheint, reagieren Sie so schnell wie m√∂glich 
            mit <b>${KEY_TARGET_PRESENT.toUpperCase()} oder ${KEY_TARGET_ABSENT.toUpperCase()}</b> (beliebige Taste).</li>
            <li style="margin-bottom: 15px;">Erscheint das "Best√§tigen"-Feld nicht, dr√ºcken Sie <b>keine</b> weitere Taste.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">Dr√ºcken Sie die <b>Leertaste</b>, um fortzufahren.</p>
      </div>
    `;

    return {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: stimulus_html,
      choices: [' '],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'block_instruction', block_name_display: blockName, block_type: blockType }
    };
  }

  function renderLayoutRandomGrid(apps, highlightTarget) {
  // Erzeuge 4x4 Positionen
  let positions = [];
  for (let row = 1; row <= 4; row++) {
    for (let col = 1; col <= 4; col++) {
      positions.push({ row, col });
    }
  }
  // shuffle positions
  for (let i = positions.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [positions[i], positions[j]] = [positions[j], positions[i]];
  }
  // benutze nur so viele Positionen wie Apps geliefert wurden (z.B. 8 oder 4)
  let usedPositions = positions.slice(0, apps.length);

  // baue HTML; die app-boxen behalten die vorhandenen CSS-Klassen
  let html = `<div class="app-grid">`;
  usedPositions.forEach((pos, idx) => {
    let app = apps[idx];
    let targetClass = (highlightTarget && app.isTarget) ? " highlight-target" : "";
    html += `<div id="app-${idx}" class="app-box${targetClass}" 
              style="grid-row: ${pos.row}; grid-column: ${pos.col};" data-app-name="${app.name}">
              ${app.name}<div class="symbol">${app.symbol}</div>
            </div>`;
  });
  html += "</div>";
  return html;
}

  const layoutRenderers = [renderLayoutRandomGrid];
  const layoutNames = ["RandomGrid4x6"];

  function getSearchTrial(apps, highlightTarget, blockLabel, probeType, blockType, isTargetPresent) {
    const randomIndex = Math.floor(Math.random() * layoutRenderers.length);
    const renderer = layoutRenderers[randomIndex];
    const layoutName = layoutNames[randomIndex];
    
    const currentTrialProbeType = probeType; 
    const expectedKey = isTargetPresent ? KEY_TARGET_PRESENT : KEY_TARGET_ABSENT;

    let currentKeyListener = null; // Variable, um den Listener zu speichern

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        let instructionText = isTargetPresent 
            ? `<b>Dr√ºcken Sie die Taste ${KEY_TARGET_PRESENT.toUpperCase()}, sobald Sie die Ziel-App entdeckt haben!</b>`
            : `<b>Dr√ºcken Sie die Taste ${KEY_TARGET_ABSENT.toUpperCase()}, sobald Sie festgestellt haben, dass die Ziel-App NICHT vorhanden ist!</b>`;

        let html = `<div class="app-container">` + renderer(apps, highlightTarget) + `</div>
        <div style="margin-top:2em; font-size:1.2vw; color:#333;">${instructionText}</div>`;
        return html;
      },
      choices: 'NO_KEYS', 
      prompt: '',
      data: { 
        trial_stage: 'search_task', 
        block_type: blockType, 
        original_block_label: blockLabel,
        is_target_highlighted: highlightTarget, 
        layout: layoutName,
        probe_type: currentTrialProbeType,
        is_target_present: isTargetPresent,
        expected_key_search: expectedKey 
      }, 
      on_load: (trial) => {
        showSAPBackground(true);
        window.currentGridApps = apps.map(x => ({...x}));
        window.gridPositions = [];
        document.querySelectorAll('.app-box').forEach((box,i) => {
          window.gridPositions.push({
            i: i,
            style: box.getAttribute('style')
          });
        });
        window.memoryCheckTargetIdx = apps.findIndex(a => a.isTarget); 

        window.appScreenStart = performance.now();
        window.appRects = apps.map((a, i) => {
          const el = document.getElementById('app-' + i).getBoundingClientRect();
          return {
            name: a.name,
            x: el.left,
            y: el.top,
            width: el.width,
            height: el.height,
            isTarget: a.isTarget
          }
        });

        let trialFinished = false; // Flag, um sicherzustellen, dass finishTrial nur einmal aufgerufen wird
        let accidentalKeyPressListener = null; // Deklariert f√ºr Hauptblock `no-probe` Logik
        let noProbeTimeout = null; // Deklariert f√ºr Hauptblock `no-probe` Logik


        currentKeyListener = (e) => { // Definition des Listeners
          const pressedKey = e.key.toLowerCase();
          if (pressedKey === KEY_TARGET_PRESENT || pressedKey === KEY_TARGET_ABSENT) { 
            e.preventDefault(); 
            if (!trialFinished) { // Pr√ºfung des Flags
              trialFinished = true; // Setzen des Flags
              const rt_select = performance.now() - window.appScreenStart;
              
              const isResponseCorrect = (pressedKey === expectedKey);

              let appRect = null;
              if (isTargetPresent) { 
                  const targetRectIdx = apps.findIndex(a => a.isTarget);
                  if (targetRectIdx !== -1) {
                      let targetEl = document.getElementById('app-' + targetRectIdx);
                      if (targetEl) appRect = targetEl.getBoundingClientRect();
                  }
              }
              window.appPosition = appRect ? { x: appRect.left, y: appRect.top, width: appRect.width, height: appRect.height } : null;

              const searchPhaseData = {
                  rt_select: rt_select,
                  response_key_search: pressedKey, 
                  is_response_correct_search: isResponseCorrect, 
                  app1_position_x: window.appPosition ? window.appPosition.x : null,
                  app1_position_y: window.appPosition ? window.appPosition.y : null,
              };

              // Listener entfernen, sobald eine g√ºltige Eingabe erfolgt ist
              document.removeEventListener('keydown', currentKeyListener, true);
              currentKeyListener = null; // Referenz l√∂schen

              // --- NEUE LOGIK F√úR NO-PROBE TRIALS IM HAUPTBLOCK ---
              if (currentTrialProbeType === 'no-probe') {
                  const startTimeForNoProbeWait = performance.now();
                  const noProbeWaitDuration = 1500; // 2 Sekunden

                  let noProbeTrialFullyFinished = false; // Lokales Flag f√ºr diesen spezifischen no-probe Handler

                  accidentalKeyPressListener = (e_accidental) => {
                      const pressedKeyAccidental = e_accidental.key.toLowerCase();
                      if ((pressedKeyAccidental === KEY_TARGET_PRESENT || pressedKeyAccidental === KEY_TARGET_ABSENT) && !noProbeTrialFullyFinished) {
                          e_accidental.preventDefault();
                          noProbeTrialFullyFinished = true; // Verhindert mehrfache Aufrufe
                          document.removeEventListener('keydown', accidentalKeyPressListener, true);
                          clearTimeout(noProbeTimeout); // Stoppt den normalen Timeout

                          // Beende den Trial und speichere, dass eine versehentliche Taste gedr√ºckt wurde
                          jsPsych.finishTrial({
                              ...searchPhaseData,
                              confirm_position_x: null, 
                              confirm_position_y: null, 
                              rt_confirm: performance.now() - startTimeForNoProbeWait,
                              response_key_confirm: pressedKeyAccidental,
                              probe_type: currentTrialProbeType,
                              confirm_tries: null,       
                              accidental_keypress_no_probe: true // Datenpunkt: ja, versehentliche Taste gedr√ºckt
                          });
                      }
                  };
                  document.addEventListener('keydown', accidentalKeyPressListener, true); // Listener f√ºr versehentliche Tasten

                  noProbeTimeout = setTimeout(() => {
                      if (!noProbeTrialFullyFinished) { // Nur beenden, wenn keine versehentliche Tasteneingabe erfolgte
                          noProbeTrialFullyFinished = true;
                          document.removeEventListener('keydown', accidentalKeyPressListener, true); // Entferne den Listener

                          jsPsych.finishTrial({
                              ...searchPhaseData,
                              confirm_position_x: null, 
                              confirm_position_y: null, 
                              rt_confirm: null,         
                              response_key_confirm: null, 
                              probe_type: currentTrialProbeType,
                              confirm_tries: null,       
                              accidental_keypress_no_probe: false // Datenpunkt: nein, keine versehentliche Taste gedr√ºckt
                          });
                      }
                  }, noProbeWaitDuration); // Warte 1.5s
              } 
              // --- ENDE NEUE LOGIK F√úR NO-PROBE TRIALS IM HAUPTBLOCK ---
              else {
                  setTimeout(() => showConfirmButton((confirmData) => { 
                    const confirmPosition = window.confirmPosition; 
                    jsPsych.finishTrial({ 
                      ...searchPhaseData,
                      confirm_position_x: confirmPosition ? confirmPosition.x : null,
                      confirm_position_y: confirmPosition ? confirmPosition.y : null,
                      ...confirmData 
                    });
                  }, false, currentTrialProbeType), CONFIRM_BUTTON_DELAY_MS); 
              }
            }
          }
        };
        document.addEventListener('keydown', currentKeyListener, true); // Listener hinzuf√ºgen
      },
      on_unload: () => { // Sicherstellen, dass der Listener im Zweifelsfall entfernt wird
        if (currentKeyListener) {
            document.removeEventListener('keydown', currentKeyListener, true);
            // currentKeyListener = null; // Nicht n√∂tig, da es eine lokale Variable ist und aus dem Scope f√§llt
        }
        // Zus√§tzlicher Cleanup f√ºr den accidentalKeyPressListener und Timeout, falls der Trial vorzeitig beendet wird
        // Diese Variablen m√ºssen in einem gemeinsamen Scope deklariert werden, damit on_unload darauf zugreifen kann.
        // Die aktuelle Implementierung deklariert sie innerhalb des if-Blocks des KeyListeners, was on_unload den Zugriff verwehrt.
        // Sollten Probleme auftreten, m√ºssten die Scopes angepasst werden.
      }
    };
  }


  // ==== PRACTICE TRIAL ====
  // Definiere die Konfigurationen f√ºr die √úbungstrials
  const practiceTrialConfigurations = [
      { isTargetPresent: true, probeType: 'on-probe' },
      { isTargetPresent: false, probeType: 'on-probe' },
      { isTargetPresent: true, probeType: 'off-probe' },
      { isTargetPresent: false, probeType: 'off-probe' },
      { isTargetPresent: true, probeType: 'no-probe' },
      { isTargetPresent: false, probeType: 'no-probe' },
      // Optional: Wiederhole einige Typen f√ºr zus√§tzliche √úbung
      { isTargetPresent: true, probeType: 'on-probe' }, 
      { isTargetPresent: false, probeType: 'off-probe' } 
  ];
  const totalPracticeTrials = practiceTrialConfigurations.length; 

  function createSinglePracticeTrial(highlight, trialNum, blockType, fixedTargetApp, practiceConfig) { 
  // √úbung: nur 4 sichtbare Apps (1 Target + 3 Distraktoren),
  // diese werden in einem 4x4 Grid gerendert, d.h. es gibt leere Zellen
  const isTargetPresent = practiceConfig.isTargetPresent; // Bestimmt, ob die Ziel-App vorhanden ist
  const probeType = practiceConfig.probeType; // Bestimmt den Probe-Typ f√ºr diesen √úbungstrial
  const numAppsInGrid = 4; // Practice trials always use 4 app boxes in a 4x4 grid

  let practiceApps = [];
  const tempDistractorPool = appNames.filter(name => name !== fixedTargetApp.name);
  let distractors;

  if (isTargetPresent) {
    // 1 Target + 3 Distraktoren
    distractors = jsPsych.randomization.sampleWithoutReplacement(tempDistractorPool, numAppsInGrid - 1); // 3 Distraktoren
    practiceApps = distractors.map(name => ({
      name: name,
      symbol: symbols[Math.floor(Math.random() * symbols.length)],
      isTarget: false
    }));
    practiceApps.push({
      name: fixedTargetApp.name,
      symbol: fixedTargetApp.symbol, 
      isTarget: true
    });
  } else {
    // 4 Distraktoren (kein Target)
    distractors = jsPsych.randomization.sampleWithoutReplacement(tempDistractorPool, numAppsInGrid);
    practiceApps = distractors.map(name => ({
      name: name,
      symbol: symbols[Math.floor(Math.random() * symbols.length)],
      isTarget: false
    }));
    // Kein Target hinzugef√ºgt
  }

  // mische die 4 Apps
  practiceApps = jsPsych.randomization.shuffle(practiceApps);

  const expectedKey = isTargetPresent ? KEY_TARGET_PRESENT : KEY_TARGET_ABSENT;

  let practiceKeyListener = null; // Variable, um den Listener zu speichern

  const practiceSearchTrial = {
    // *** √ÑNDERUNG HIER: `jsPsychHtmlButtonResponse` wurde zu `jsPsychHtmlKeyboardResponse` ge√§ndert ***
    // *** `choices: 'NO_KEYS'` wurde zu `choices: []` ge√§ndert, um den Prompt zu unterdr√ºcken ***
    type: jsPsychHtmlKeyboardResponse,
    stimulus: () => {
      // Wir nutzen denselben renderer renderLayoutRandomGrid, der jetzt 4x4 Positionen zur Verf√ºgung hat.
      // Da wir nur 4 Apps √ºbergeben, erscheinen genau 4 Boxen in zuf√§lligen Zellen des 4x4 Grids.
      window.currentGridApps = practiceApps;
      window.memoryCheckTargetIdx = practiceApps.findIndex(a => a.isTarget); // Ist -1, wenn Target nicht vorhanden

      let thoughtBubbleHTML = '';
      if (blockType === '√úbung') { 
        const keyPresentText = `<span style="font-weight: bold; color: #186FDB;">${KEY_TARGET_PRESENT.toUpperCase()}</span>`;
        const keyAbsentText = `<span style="font-weight: bold; color: #186FDB;">${KEY_TARGET_ABSENT.toUpperCase()}</span>`;
        
        let presenceText = isTargetPresent 
          ? `<b>vorhanden</b>` 
          : `<b>NICHT vorhanden</b>`;
        
        let actionText = isTargetPresent 
          ? `du die Ziel-App siehst. Dr√ºcke die Taste ${keyPresentText}.` 
          : `du festgestellt hast, dass die Ziel-App nicht im Raster ist. Dr√ºcke die Taste ${keyAbsentText}.`;

        let confirmInstruction;
        if (probeType === 'no-probe') {
            confirmInstruction = `<p><b>Wichtig:</b> In diesem Trial wird <b>kein</b> "Best√§tigen"-Feld erscheinen. Der Trial endet automatisch nach deiner ersten Reaktion. Merke dir: danach KEINE Taste dr√ºcken, das Raster bleibt noch 1.5s sichtbar!</p>`;
        } else {
            confirmInstruction = `<p>Danach erscheint das "Best√§tigen"-Feld, auf das du ebenfalls mit ${keyPresentText} oder ${keyAbsentText} reagieren sollst.</p>`;
        }

        thoughtBubbleHTML = `
          <div class="thought-bubble">
            <p><b>Achtung!</b> In diesem Trial ist die Ziel-App ${presenceText}.</p>
            <p>Reagiere, sobald ${actionText}</p>
            ${confirmInstruction}
            <p>Konzentriere dich auf schnelle und korrekte Reaktionen!</p>
          </div>
        `;
      }

      return `
        <div class="practice-area">
          <div class="app-container">
            ${renderLayoutRandomGrid(practiceApps, highlight)}
          </div>
          ${thoughtBubbleHTML}
        </div>
        <div style="margin-top:2em; font-size:1.2vw; color:#333; display: none;"></div>
      `;
    },
    
    choices: [], // <--- GE√ÑNDERT: Leeres Array, um interne Tastatur-Abfrage zu deaktivieren
    prompt: '', // <--- Bleibt leer, um den Prompt-Text zu unterdr√ºcken
    data: {
      trial_stage: 'search_task',
      block_type: blockType,
      original_block_label: `√úbungstrial ${trialNum} (${probeType})`,
      is_target_present: isTargetPresent, 
      expected_key_search: expectedKey,
      probe_type_practice: probeType // Speichere den Probe-Typ des √úbungstrials
    },
    on_load: (trial) => { 
      showSAPBackground(true);
      // update rectangles usw. (wie zuvor)
      window.appRects = [];
      document.querySelectorAll('.app-box').forEach((box, i) => {
        const el = box.getBoundingClientRect();
        window.appRects.push({
          name: window.currentGridApps[i].name,
          x: el.left,
          y: el.top,
          width: el.width,
          height: el.height,
          isTarget: window.currentGridApps[i].isTarget
        });
      });
      window.appScreenStart = performance.now();

      // --- HIER WIRD DIE DENKBLASE ROT HERVORGEHOBEN ---
      const thoughtBubbleEl = document.querySelector('.thought-bubble');
      // Highlight: erster Trial, zweiter Trial, oder wenn probeType 'no-probe' ist
      if (thoughtBubbleEl && (trialNum === 1 || trialNum === 2 || probeType === 'no-probe')) {
          thoughtBubbleEl.classList.add('highlight-red');
          setTimeout(() => {
              thoughtBubbleEl.classList.remove('highlight-red');
          }, FEEDBACK_DURATION_MS * 1.5); // Etwas l√§nger sichtbar lassen als das normale Feedback
      }
      // --- ENDE HIGHLIGHT ---

      let trialFinished = false; // Flag, um sicherzustellen, dass finishTrial nur einmal aufgerufen wird

      practiceKeyListener = (e) => { // Definition des Listeners
        const pressedKey = e.key.toLowerCase();
        // Beide Tasten (j und f) f√ºr die Reaktion zulassen
        if (pressedKey === KEY_TARGET_PRESENT || pressedKey === KEY_TARGET_ABSENT) {
          e.preventDefault();
          if (!trialFinished) { // Pr√ºfung des Flags
            trialFinished = true; // Setzen des Flags
            const rt_select = performance.now() - window.appScreenStart;
            
            let appRect = null;
            let targetAppElement = null; // Element der Ziel-App, falls vorhanden und hervorgehoben werden soll
            if (isTargetPresent) { // Nur nach Target-Rechteck suchen, wenn Target vorhanden war
                const targetIdx = practiceApps.findIndex(a => a.isTarget);
                if (targetIdx !== -1) {
                    targetAppElement = document.getElementById('app-' + targetIdx); // Speichere das Element
                    if (targetAppElement) appRect = targetAppElement.getBoundingClientRect();
                }
            }
            window.appPosition = appRect ? { x: appRect.left, y: appRect.top, width: appRect.width, height: appRect.height } : null;

            const isResponseCorrect = (pressedKey === expectedKey); // Korrektheit pr√ºfen

            const searchPhaseData = {
              rt_select: rt_select,
              response_key_search: pressedKey,
              is_response_correct_search: isResponseCorrect, // Korrektheitsflag
              app1_position_x: window.appPosition ? window.appPosition.x : null,
              app1_position_y: window.appPosition ? window.appPosition.y : null,
            };

            // Listener entfernen, sobald eine g√ºltige Eingabe erfolgt ist
            document.removeEventListener('keydown', practiceKeyListener, true);
            practiceKeyListener = null; // Referenz l√∂schen

            // --- Feedback-Logik f√ºr √úbungstrial ---
            const feedbackDiv = document.createElement('div');
            feedbackDiv.className = 'feedback-text-overlay';
            
            if (isResponseCorrect) {
                feedbackDiv.textContent = 'Richtig';
                feedbackDiv.classList.add('correct'); // Gr√ºne Farbe f√ºr richtig
                
                // Highlight f√ºr Target-Present bei korrekter Antwort
                if (isTargetPresent && targetAppElement) { // Nur highlighten, wenn Target da ist UND Element gefunden wurde
                   targetAppElement.classList.add('correct-feedback-highlight-green');
                }
            } else {
                feedbackDiv.textContent = 'Falsch';
                feedbackDiv.classList.add('incorrect'); // Rote Farbe f√ºr falsch
            }
            
            document.body.appendChild(feedbackDiv);

            setTimeout(() => {
                feedbackDiv.remove(); // Feedback-Text entfernen
                if (targetAppElement) { // Highlight von Target-App entfernen
                    targetAppElement.classList.remove('correct-feedback-highlight-green');
                }
                
                if (probeType === 'no-probe') {
                    // Logik f√ºr no-probe √úbungstrials: zus√§tzliche Reaktionen abfangen
                    let accidentalKeyPressListener = null;
                    const startTimeForNoProbeWait = performance.now();
                    const noProbeWaitDuration = 1500; // 1.5 Sekunden

                    let noProbeTrialFullyFinished = false;

                    accidentalKeyPressListener = (e_accidental) => {
                        const pressedKeyAccidental = e_accidental.key.toLowerCase();
                        if ((pressedKeyAccidental === KEY_TARGET_PRESENT || pressedKeyAccidental === KEY_TARGET_ABSENT) && !noProbeTrialFullyFinished) {
                            e_accidental.preventDefault();
                            noProbeTrialFullyFinished = true; // Verhindert mehrfache Aufrufe
                            document.removeEventListener('keydown', accidentalKeyPressListener, true);
                            clearTimeout(noProbeTimeout); // Stoppt den normalen Timeout

                            const accidentalFeedbackDiv = document.createElement('div');
                            accidentalFeedbackDiv.className = 'feedback-text-overlay incorrect';
                            accidentalFeedbackDiv.textContent = 'Fehler: Hier erschien kein Best√§tigen-Feld!';
                            document.body.appendChild(accidentalFeedbackDiv);

                            setTimeout(() => {
                                accidentalFeedbackDiv.remove();
                                jsPsych.finishTrial({
                                    ...searchPhaseData,
                                    rt_confirm: performance.now() - startTimeForNoProbeWait, // Zeit, ab der Best√§tigen-Button erschienen *w√§re*
                                    response_key_confirm: pressedKeyAccidental,
                                    probe_type: probeType,
                                    confirm_tries: null,
                                    accidental_keypress_no_probe: true // Benutzerdefinierter Datenwert
                                });
                            }, NO_PROBE_ERROR_FEEDBACK_DURATION_MS); // Hier die l√§ngere Dauer
                        }
                    };
                    document.addEventListener('keydown', accidentalKeyPressListener, true);

                    const noProbeTimeout = setTimeout(() => {
                        if (!noProbeTrialFullyFinished) { // Nur beenden, wenn keine versehentliche Tasteneingabe erfolgte
                            noProbeTrialFullyFinished = true;
                            document.removeEventListener('keydown', accidentalKeyPressListener, true);

                            // Feedback "Sehr gut!" f√ºr korrekte Nicht-Reaktion
                            const goodJobFeedbackDiv = document.createElement('div');
                            goodJobFeedbackDiv.className = 'feedback-text-overlay correct'; // Gr√ºne Farbe f√ºr richtig
                            goodJobFeedbackDiv.textContent = 'Sehr gut!';
                            document.body.appendChild(goodJobFeedbackDiv);

                            setTimeout(() => {
                                goodJobFeedbackDiv.remove(); // Feedback nach kurzer Zeit entfernen
                                jsPsych.finishTrial({
                                    ...searchPhaseData,
                                    rt_confirm: null,
                                    response_key_confirm: null,
                                    probe_type: probeType,
                                    accidental_keypress_no_probe: false
                                });
                            }, FEEDBACK_DURATION_MS); // Zeigt "Sehr gut!" f√ºr die Standard-Feedback-Dauer
                        }
                    }, noProbeWaitDuration); // Warte 1.5s

                } else {
                    // Standardfall f√ºr on-probe und off-probe: Best√§tigen-Button anzeigen
                    setTimeout(() => showConfirmButton((confirmData) => jsPsych.finishTrial({ ...searchPhaseData, ...confirmData }), true, probeType), CONFIRM_BUTTON_DELAY_MS);
                }
            }, FEEDBACK_DURATION_MS);
            // --- ENDE FEEDBACK LOGIK ---
          }
        }
      };
      document.addEventListener('keydown', practiceKeyListener, true); // Listener hinzuf√ºgen
    },
    on_unload: () => { // Sicherstellen, dass der Listener im Zweifelsfall entfernt wird
      if (practiceKeyListener) {
          document.removeEventListener('keydown', practiceKeyListener, true);
          practiceKeyListener = null;
      }
    }
  };

  return [
    // Fixation vor √úbungs-Suchtrial behalten
    getFixationTrial(blockType),
    practiceSearchTrial
  ];
}

  // makePracticeBlock wurde angepasst, um den displayBlockName als Argument zu akzeptieren
  function makePracticeBlock(highlight, displayBlockName) {
    const step2_instruction = highlight
      ? `Finden Sie die Ziel-App im Raster. Sie ist zur Hilfe <b>mit einem dunkelgrauen Rahmen markiert</b>.`
      : `Finden Sie die Ziel-App im Raster.`;

    const practiceInstructionStimulus = `
      <div style="max-width: 800px; margin: 0 auto; text-align: left; font-size: 18px; line-height: 1.6;">
        <h2 style="text-align: center; font-size: 2.2em; margin-bottom: 25px;">√úbungsrunde f√ºr ${displayBlockName}</h2>
        <p>Wir beginnen mit einer kurzen √úbungsrunde mit <b>${totalPracticeTrials}</b> Durchg√§ngen, um alle 
          Szenarien des Experiments kennenzulernen. Bitte f√ºhren Sie die folgenden Schritte so schnell und genau 
          wie m√∂glich aus:</p>
        <ol style="margin: 20px 0 20px 20px; padding-left: 20px;">
          <li style="margin-bottom: 15px;">Pr√§gen Sie sich die <b>Ziel-App</b> ein, die Ihnen zu Beginn gezeigt wird.</li>
          <li style="margin-bottom: 15px;">${step2_instruction} Dr√ºcken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}
            </b>, wenn Sie die Ziel-App entdecken, oder <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie 
            feststellen, dass sie nicht vorhanden ist.</li> 
          <li style="margin-bottom: 15px;"><b>Achtung:</b> Oft erscheint ein Feld mit "<b>Best√§tigen</b>", auf das 
            Sie mit der <b>Taste ${KEY_TARGET_PRESENT.toUpperCase()} oder ${KEY_TARGET_ABSENT.toUpperCase()}</b> 
            reagieren m√ºssen. Manchmal wird das "Best√§tigen"-Feld jedoch <b>NICHT</b> erscheinen. Der Trial endet dann nach
             kurzer Zeit automatisch. Dr√ºcken Sie in diesem Fall <b>KEINE weitere Taste</b>.</li>
        </ol>
        <p style="text-align: center; margin-top: 30px;">W√§hrend der √úbung werden Sie f√ºr jedes Szenario 
          (Ziel-App vorhanden/nicht vorhanden, Best√§tigen-Feld erscheint/nicht erscheint) nochmal an der 
          Seite die Instruktionen sehen. Bei korrekter Reaktion erhalten Sie ein kurzes Feedback.</p>
        <p style="text-align: center; margin-top: 30px;">Dr√ºcken Sie die <b>Leertaste</b>, um die √úbung zu beginnen.</p>
      </div>
    `;

    const practiceInstructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: practiceInstructionStimulus, 
      choices: [' '],
      css_classes: ['vertically-centered-content'],
      on_load: () => showSAPBackground(false),
      on_finish: () => showSAPBackground(true),
      data: { trial_stage: 'practice_instruction', block_type: '√úbung' }
    };

    const practice_timeline = [practiceInstructions];

    const practiceTargetApp = {
        name: jsPsych.randomization.sampleWithoutReplacement(appNames, 1)[0],
        symbol: symbols[Math.floor(Math.random() * symbols.length)]
    };
    
    practice_timeline.push(getShowTarget(practiceTargetApp, highlight, '√úbung'));

    for (let i = 0; i < totalPracticeTrials; i++) {
        const practiceConfig = practiceTrialConfigurations[i];
        const single_trial_nodes = createSinglePracticeTrial(highlight, i + 1, '√úbung', practiceTargetApp, practiceConfig);
        practice_timeline.push(...single_trial_nodes);
    }
    
    // Debouncer Trial, um √ºberlappende Tastendr√ºcke abzufangen
    const debouncerTrial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '<div style="visibility: hidden;">.</div>', // Unsichtbares Stimulus
        choices: "NO_KEYS", // Reagiert nicht auf Tasten
        trial_duration: 200, // Kurze Dauer von 200ms
        on_load: () => showSAPBackground(false), // Hintergrund bleibt konsistent
        on_finish: () => showSAPBackground(false), // Hintergrund bleibt konsistent
        data: { trial_stage: 'debounce', block_type: '√úbung' }
    };
    practice_timeline.push(debouncerTrial);

    const practiceCompletionMessage = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
          <div style="max-width: 900px; margin: 0 auto; text-align: left;">
            <h2>Die √úbungsrunde f√ºr ${displayBlockName} ist beendet.</h2>
            <p>Es beginnt nun der Hauptteil des Experiments.</p>
            <p>Denken Sie daran:</p>
            <ul style="margin: 20px 0 20px 20px; padding-left: 20px;">
                <li>Reagieren Sie auf die Ziel-App so schnell und genau wie m√∂glich.</li>
                <li>Dr√ºcken Sie die Taste <b>${KEY_TARGET_PRESENT.toUpperCase()}</b>, wenn Sie die Ziel-App entdecken.</li>
                <li>Dr√ºcken Sie die Taste <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>, wenn Sie feststellen, dass die Ziel-App nicht vorhanden ist.</li>
                <li><b>Wichtig:</b> Wenn das "Best√§tigen"-Feld NICHT erscheint, dr√ºcken Sie KEINE weitere Taste. 
                  Das Raster bleibt 1,5 Sekunden sichtbar, danach geht es automatisch weiter.</li>
                  <li><b>In den nachfolgenden Trials gibt es kein Feedback mehr f√ºr richtige oder falsche Reaktionen auf Ziel-App 
                    und Best√§tigen-Feld.</b></li>
            </ul>
            <p style="text-align: center; margin-top: 30px;">Dr√ºcken Sie die <b>Leertaste</b>, um mit dem Hauptteil fortzufahren.</p>
          </div>
        `,
        choices: [' '],
      css_classes: ['vertically-centered-content'],
      on_load: (trial) => {
          console.log(`[JSPSYCH] Loading practice completion message for block: ${displayBlockName}`); // Debugging-Ausgabe
          showSAPBackground(false);
      },
      on_finish: () => {
          console.log(`[JSPSYCH] Finished practice completion message for block: ${displayBlockName}`); // Debugging-Ausgabe
          showSAPBackground(true);
      },
      data: { trial_stage: 'practice_end_transition', block_type: '√úbung', block_name_for_summary: displayBlockName }
    };
    practice_timeline.push(practiceCompletionMessage);


    return practice_timeline;
  }

  const numTargetsPerExperiment = 12; 
  const allExperimentTargetNames = jsPsych.randomization.sampleWithoutReplacement(appNames, numTargetsPerExperiment);

  // Der globalDistractorPool enth√§lt alle App-Namen, die NIEMALS Ziel-Apps sein werden (weder jetzt noch sp√§ter)
  const globalDistractorPool = appNames.filter(name => !allExperimentTargetNames.includes(name));

  function makeBlockTrials(highlight, blockLabel, trialConditionsArr, internalBlockNum, displayBlockNum) {
    const block = [];

    // Der displayBlockNum wird f√ºr die Anzeige an den Benutzer verwendet
    const displayBlockName = `Block ${displayBlockNum}`;

    // Der internalBlockNum wird weiterhin f√ºr die Datenspeicherung verwendet
    // const currentBlockNum = blockOrderNumber; // Diese Zeile entfernen oder auskommentieren

    block.push(getInstructions(displayBlockName, highlight, blockLabel));

    // makePracticeBlock nutzt nun auch displayBlockName
    block.push(...makePracticeBlock(highlight, displayBlockName));

    let targetsForThisBlockNames;
    // Die Logik zur Auswahl der Ziel-Apps sollte weiterhin vom internalBlockNum (0 oder 1) abh√§ngen,
    // da dies die tats√§chliche Reihenfolge der Bl√∂cke repr√§sentiert.
    if (internalBlockNum === 0) { // Dies ist der erste Block im Experiment (intern 0)
        targetsForThisBlockNames = allExperimentTargetNames.slice(0, 6);
    } else { // Dies ist der zweite Block im Experiment (intern 1)
        targetsForThisBlockNames = allExperimentTargetNames.slice(6, 12);
    }

    const blockTargets = targetsForThisBlockNames.map(name => ({
        name: name,
        symbol: symbols[Math.floor(Math.random() * symbols.length)]
    }));

    let currentTargetIdx = 0;
    block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel));

    for (let i = 0; i < trialsPerBlock; i++) {
        if (i > 0 && i % 20 === 0) {
            currentTargetIdx = (currentTargetIdx + 1) % blockTargets.length;
            block.push(getShowTarget(blockTargets[currentTargetIdx], highlight, blockLabel));
        }

        const currentCondition = trialConditionsArr[i];
        let currentTarget = blockTargets[currentTargetIdx];

        let gridAppsNames;
        const numAppsInGrid = 8;

        if (currentCondition.isTargetPresent) {
            const availableDistractors = globalDistractorPool.filter(name => name !== currentTarget.name);
            gridAppsNames = jsPsych.randomization.sampleWithoutReplacement(availableDistractors, numAppsInGrid - 1);
            gridAppsNames.push(currentTarget.name);
        } else {
            const availableDistractors = globalDistractorPool.filter(name => name !== currentTarget.name);
            gridAppsNames = jsPsych.randomization.sampleWithoutReplacement(availableDistractors, numAppsInGrid);
        }

        let gridApps = jsPsych.randomization.shuffle(gridAppsNames).map(name => ({
            name: name,
            symbol: (currentCondition.isTargetPresent && name === currentTarget.name)
                ? currentTarget.symbol
                : symbols[Math.floor(Math.random() * symbols.length)],
            isTarget: (currentCondition.isTargetPresent && name === currentTarget.name)
        }));

        block.push(getFixationTrial(blockLabel));
        block.push(getSearchTrial(
            gridApps,
            highlight,
            blockLabel,
            currentCondition.probeType,
            blockLabel,
            currentCondition.isTargetPresent
        ));
    }

    // Alle Trials dieses Blocks mit internalBlockNum markieren
    block.forEach(trial => {
        if (!trial.data) trial.data = {};
        trial.data.block_num = internalBlockNum; // WICHTIG: Hier wird der interne Block gez√§hlt (0 oder 1)
    });
    return block;
}


  function getRectDistance(rect1, rect2) {
      const r1 = {x1: rect1.x, y1: rect1.y, x2: rect1.x + rect1.width, y2: rect1.y + rect1.height};
      const r2 = {x1: rect2.x, y1: rect2.y, x2: rect2.x + rect2.width, y2: rect2.y + rect1.height}; 
      const dx = Math.max(0, r1.x1 - r2.x2, r2.x1 - r1.x2);
      const dy = Math.max(0, r1.y1 - r2.y2, r2.y1 - r1.y2);
      return Math.sqrt(dx * dx + dy * dy);
  }

  function getOverlapArea(rect1, rect2) {
      const x_overlap = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x));
      const y_overlap = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
      return x_overlap * y_overlap;
  }


  const showConfirmButton = (callback, isPractice = false, probeType = null) => {
  if (probeType === 'no-probe') {
    callback({
      rt_confirm: null,
      response_key_confirm: null,
      probe_type: probeType,
      confirm_tries: 0,
      confirm_position_x: null,
      confirm_position_y: null
    });
    return;
  }

  const confirm = document.createElement('div');
  confirm.className = 'confirm-box';
  confirm.textContent = 'Best√§tigen';

  const paddingY = window.innerHeight * 0.05;
  const paddingX = window.innerWidth * 0.05;

  const minimumTopInPixels = 140;
  const topBoundary = Math.max(minimumTopInPixels, window.innerHeight * 0.10);
  const bottomBoundary = window.innerHeight - paddingY;
  const leftBoundary = paddingX;
  const rightBoundary = window.innerWidth - paddingX;

  // Tempor√§re Platzierung, um Gr√∂√üe zu messen
  confirm.style.position = 'absolute';
  confirm.style.left = '-1000px';
  confirm.style.top = '-1000px';
  document.body.appendChild(confirm);

  const buttonW = confirm.offsetWidth;
  const buttonH = confirm.offsetHeight;
  const buttonArea = buttonW * buttonH;

  // *** HIER IST DIE ANPASSUNG F√úR DIE GRENZE DES BEST√ÑTIGEN-BUTTONS ***
  // Vermeide die √§u√üerste rechte Bildschirmzone: 15% der Breite oder mindestens 100px
  const avoidRightPx = Math.max(100, Math.round(window.innerWidth * 0.15)); // 15% statt 12%
  let rightBoundaryUsed = rightBoundary - avoidRightPx;

  // Fallback, falls der m√∂gliche Bereich zu eng wird (z.B. wenn der Bildschirm sehr schmal ist)
  if (rightBoundaryUsed - leftBoundary - buttonW < 20) { // Mindestbreite von 20px f√ºr den Zufallsbereich
    rightBoundaryUsed = rightBoundary - buttonW; // Fallback: Nur die Breite des Buttons abziehen
  }
  // *** ENDE DER ANPASSUNG ***

  // probeType sicherstellen
  if (isPractice && !probeType) {
    probeType = 'on-probe'; 
  } else if (!isPractice && !probeType) {
    console.error("showConfirmButton wurde ohne probeType im Haupt-Trial aufgerufen. Using fallback 'off-probe'.");
    probeType = 'off-probe';
  }

  let confirmX = leftBoundary; // Initialisierung
  let confirmY = topBoundary; // Initialisierung
  let tries = 0;
  let found = false;

  const rects = window.appRects || [];
  const nonTargetRects = rects.filter(r => !r.isTarget);
  const targetRect = rects.find(r => r.isTarget);

  let thoughtBubbleRect = null;
  // Denke daran, die Denkblase nur zu ber√ºcksichtigen, wenn sie da ist und es ein √úbungstrial ist
  if (isPractice) {
    const thoughtBubbleEl = document.querySelector('.thought-bubble');
    if (thoughtBubbleEl) {
      thoughtBubbleRect = thoughtBubbleEl.getBoundingClientRect();
    }
  }


  while (tries < 1000 && !found) {
    // X innerhalb eingeschr√§nkter Grenzen w√§hlen
    const minX = leftBoundary;
    const maxX = Math.max(minX, rightBoundaryUsed - buttonW); // Stelle sicher, dass maxX nicht kleiner als minX ist
    if (maxX <= minX) {
      // Fallback: Wenn der eingeschr√§nkte Bereich zu klein ist, nutze den gesamten verf√ºgbaren Bereich
      confirmX = leftBoundary + Math.random() * (rightBoundary - leftBoundary - buttonW);
    } else {
      confirmX = minX + Math.random() * (maxX - minX);
    }
    // Y wie gehabt innerhalb der normalen Grenzen
    confirmY = topBoundary + Math.random() * (bottomBoundary - topBoundary - buttonH);

    const currentConfirmRect = { x: confirmX, y: confirmY, width: buttonW, height: buttonH };

    let hasOverlapWithThoughtBubble = false;
    if (thoughtBubbleRect) { // Nur pr√ºfen, wenn Denkblase vorhanden ist
        // √úberpr√ºfen, ob das Best√§tigen-Feld die Denkblase √ºberlappt
        if (getOverlapArea(currentConfirmRect, thoughtBubbleRect) > 0) {
            hasOverlapWithThoughtBubble = true;
        }
    }


    if (probeType === 'on-probe') {
      let hasSufficientOverlapWithNonTarget = false;
      for (const rect of nonTargetRects) {
        const overlap = getOverlapArea(currentConfirmRect, rect);
        if (overlap / buttonArea >= 1.0) {
          hasSufficientOverlapWithNonTarget = true;
          break;
        }
      }

      let overlapsTarget = false;
      if (targetRect) {
        const overlapTarget = getOverlapArea(currentConfirmRect, targetRect);
        if (overlapTarget > 0.001) overlapsTarget = true;
      }

      if (hasSufficientOverlapWithNonTarget && !overlapsTarget && !hasOverlapWithThoughtBubble) found = true;
    } else {
      // off-probe: keine √úberlappung und nicht zu nah an Apps
      let anyOverlap = false;
      let tooCloseToApps = false;
      for (const rect of rects) {
        const overlap = getOverlapArea(currentConfirmRect, rect);
        if (overlap > 0.001) {
          anyOverlap = true;
          break;
        }
        const dist = getRectDistance(currentConfirmRect, rect);
        if (dist < window.innerWidth * 0.02) {
          tooCloseToApps = true;
          break;
        }
      }
      if (!anyOverlap && !tooCloseToApps && !hasOverlapWithThoughtBubble) found = true;
    }
    tries++;
  }

  if (!found) {
    console.warn(`Konnte keine optimale Position f√ºr den 'Best√§tigen'-Button (${probeType}) nach ${tries} Versuchen finden. Platzierung k√∂nnte suboptimal sein.`);
  }

  confirm.style.left = `${confirmX}px`;
  confirm.style.top = `${confirmY}px`;

  const confirmRect = confirm.getBoundingClientRect();
  window.confirmPosition = { x: confirmRect.left, y: confirmRect.top };
  window.confirmAppearTime = performance.now();

  let confirmKeyListener = null; // Variable, um den Listener zu speichern
  let confirmFinished = false;

  confirmKeyListener = (e) => {
    const pressedKey = e.key.toLowerCase();
    if (pressedKey === KEY_TARGET_PRESENT || pressedKey === KEY_TARGET_ABSENT) {
      e.preventDefault();
      if (!confirmFinished) {
        confirmFinished = true;
        const rt_confirm = performance.now() - window.confirmAppearTime;
        const dataToReturn = {
          rt_confirm: rt_confirm,
          response_key_confirm: pressedKey,
          probe_type: probeType,
          confirm_tries: tries
        };
        // --- HIER IST DIE NEUE LOGIK F√úR DEN √úBUNGSTRIAL-BUTTON ---
        if (isPractice) {
            confirm.classList.add('correct-feedback-highlight-green'); // Highlight the button
            setTimeout(() => {
                confirm.classList.remove('correct-feedback-highlight-green'); // Remove highlight
                confirm.remove(); // Remove button
                document.removeEventListener('keydown', confirmKeyListener, true); // Listener entfernen
                confirmKeyListener = null; // Referenz l√∂schen
                callback(dataToReturn); // Finish trial
            }, FEEDBACK_DURATION_MS); // Keep it visible for FEEDBACK_DURATION_MS
        } else {
            // Original logic for actual trials: no visual feedback on button, remove immediately
            confirm.remove();
            document.removeEventListener('keydown', confirmKeyListener, true);
            confirmKeyListener = null;
            callback(dataToReturn);
        }
        // --- ENDE DER NEUEN LOGIK ---
      }
    }
  };
  document.addEventListener('keydown', confirmKeyListener, true); // Listener hinzuf√ºgen
};


  // === Timeline ===
  const block_definitions = [
    { highlight: false, label: "T", conditions: block1Conditions }, 
    { highlight: true, label: "B", conditions: block2Conditions } 
  ];

  const randomized_blocks = jsPsych.randomization.shuffle(block_definitions);

  const firstBlock = makeBlockTrials(
    randomized_blocks[0].highlight,
    randomized_blocks[0].label,
    randomized_blocks[0].conditions, 
    1 
  );

   // Bildschirm zwischen Block 1 und Block 2
   const midBlockBreak = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: () => {
      const nextBlockLabel = randomized_blocks[1].label; // Label des kommenden zweiten Blocks
      // Dies ist die Variable, die Sie oben definiert haben und die wir verwenden werden
      const isNextBlockHighlightFree = !randomized_blocks[1].highlight; // Pr√ºfen, ob der n√§chste Block KEIN Highlight hat

      let additionalInfo = '';
      // Korrektur: Verwenden Sie 'isNextBlockHighlightFree' hier
      if (isNextBlockHighlightFree) { // Wenn der n√§chste Block KEIN Highlight hat (Test-Block)
        additionalInfo = `
          <p style="color: #d32f2f; font-weight: bold; margin-top: 20px;">
            Achtung: Im folgenden Block wird die Ziel-App nicht mehr grau umrahmt sein!
          </p>
        `;
      } else { // Wenn der n√§chste Block ein Highlight hat (Baseline-Block)
        additionalInfo = `
          <p style="color: #1a6d91; font-weight: bold; margin-top: 20px;">
            Hinweis: Im folgenden Block wird die Ziel-App zur Orientierung stets grau umrahmt sein.
          </p>
        `;
      }

      return `
        <div style="max-width: 900px; margin: 0 auto; text-align: center;">
          <h2>Block 1 ist abgeschlossen!</h2>
          <p>Sie haben den ersten Teil des Experiments erfolgreich beendet.</p>
          <p>Es folgt nun der zweite und letzte Block.</p>
          ${additionalInfo} <!-- Hier wird die zus√§tzliche Info eingef√ºgt -->
          <p>Die Regeln bleiben dieselben:</p>
          <ul style="max-width: 600px; margin: 20px auto 20px auto; text-align: left; padding-left: 20px;">
              <li>Finden Sie die Ziel-App (oder stellen Sie fest, dass sie fehlt) und dr√ºcken Sie <b>${KEY_TARGET_PRESENT.toUpperCase()}</b> oder <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>.</li>
              <li>Reagieren Sie auf das "Best√§tigen"-Feld mit <b>${KEY_TARGET_PRESENT.toUpperCase()}</b> oder <b>${KEY_TARGET_ABSENT.toUpperCase()}</b>.</li>
              <li>Denken Sie daran: Manchmal erscheint das "Best√§tigen"-Feld nicht. Dr√ºcken Sie dann bitte keine weitere Taste.</li>
          </ul>
          <p>Bitte konzentrieren Sie sich weiterhin auf schnelle und genaue Reaktionen.</p>
          <p style="margin-align: center; margin-top: 30px;">Dr√ºcken Sie die <b>Leertaste</b>, um mit Block 2 zu beginnen.</p>
        </div>
      `;
    },
    choices: [' '],
    css_classes: ['vertically-centered-content'],
    on_load: () => showSAPBackground(false),
    on_finish: () => showSAPBackground(true),
    data: { trial_stage: 'inter_block_break', block_type: 'Block-√úbergang' }
  };



  const secondBlock = makeBlockTrials(
    randomized_blocks[1].highlight,
    randomized_blocks[1].label,
    randomized_blocks[1].conditions, 
    2 
  );
  
  const timeline = [
  // Schritt 1: Preload + Startseite (haben kein Blocknummern-Konzept)
  preload,
  startPage,

  // Schritt 2: Erster Block (block_num = 0)
  ...makeBlockTrials(randomized_blocks[0].highlight, randomized_blocks[0].label, block1Conditions, 0, 1),

  // Schritt 3: Pause / √úbergang
  midBlockBreak,

  // Schritt 4: Zweiter Block (block_num = 1)
  ...makeBlockTrials(randomized_blocks[1].highlight, randomized_blocks[1].label, block2Conditions, 1, 2)
];

jsPsych.run(timeline);


</script>
</body>
</html>